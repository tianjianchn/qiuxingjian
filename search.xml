<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>微前端实践</title>
      <link href="/micro-frontend-practice/"/>
      <url>/micro-frontend-practice/</url>
      
        <content type="html"><![CDATA[<p>在 toB 的前端开发工作中，我们往往就会遇到如下困境：</p><ol><li>工程越来越大，打包越来越慢</li><li>团队人员多，产品功能复杂，代码冲突频繁、影响面大</li><li>内心想做 SaaS 产品，但客户总是要做定制化</li></ol><p>不同的团队可能有不同的方法去解决这些问题。在前端开发日新月异、前端工程化蓬勃发展的今天，我想给大家介绍下另一种尝试——微前端。<br><a id="more"></a></p><h2 id="微前端是什么"><a href="#微前端是什么" class="headerlink" title="微前端是什么"></a>微前端是什么</h2><p>那什么是微前端？微前端主要是借鉴后端微服务的概念。简单地说，就是将一个巨无霸（Monolith）的前端工程拆分成一个一个的小工程。别小看这些小工程，它们也是“麻雀虽小，五脏俱全”，完全具备独立的开发、运行能力。整个系统就将由这些小工程协同合作，实现所有页面的展示与交互。</p><p><img src="/images/micro-service-vs-micro-frontend.png" alt=""><br>可以跟微服务这么对比着去理解：</p><table><thead><tr><th style="text-align:center">微服务</th><th style="text-align:center">微前端</th></tr></thead><tbody><tr><td style="text-align:center">一个微服务就是由一组接口构成，接口地址一般是 URL。当微服务收到一个接口的请求时，会进行路由找到相应的逻辑，输出响应内容。</td><td style="text-align:center">一个微前端则是由一组页面构成，页面地址也是 URL。当微前端收到一个页面 URL 的请求时，会进行路由找到相应的组件，渲染页面内容。</td></tr><tr><td style="text-align:center">后端微服务会有一个网关，作为单一入口接收所有的客户端接口请求，根据接口 URL 与服务的匹配关系，路由到对应的服务。</td><td style="text-align:center">微前端则会有一个加载器，作为单一入口接收所有页面 URL 的访问，根据页面 URL 与微前端的匹配关系，选择加载对应的微前端，由该微前端进行进行路由响应 URL。</td></tr></tbody></table><p>这里要注意跟 iframe 实现页面嵌入机制的区别。微前端没有用到 iframe，它很纯粹地利用 JavaScript、MVVM 等技术来实现页面加载。后面我们将介绍相关的技术实现。</p><h2 id="为什么要用微前端"><a href="#为什么要用微前端" class="headerlink" title="为什么要用微前端"></a>为什么要用微前端</h2><p>在介绍具体的改造方式之前，我想跟大家先说明下我们当时面临的问题，以及改造后的对比，以便大家以此为对照，评判或决定使用。主要包括打包速度、页面加载速度、多人多地协作、SaaS 产品定制化、产品拆分这几个角度。</p><p>首先是打包速度。在 6 个月前，我们的 B 端工程那会儿还是一个 Monolith。当时已经有 20 多个依赖、60 多个公共组件、200 多个页面，对接 700 多个接口。我们使用了 Webpack 2，并启用 DLL Plugin、HappyPack 4。在我的个人主机上使用 4 线程编译，大概要 5 分钟。而如果不拆分，算下来现在我们已经有近 400 个页面，对接1000 多个接口。<br>这个时间意味着什么？它不仅会耽误我们开发人员的时间，还会影响整个团队的效率。上线时，在 Docker、CI 等环境下，耗时还会被延长。如果部署后出几个 Bug，要线上立即修复，那就不知道要熬到几点了。<br>在使用微前端改造后，目前我们已经有 26 个微前端工程，平均打包时间在 30-45 秒之间（注意，这里还没有应用 DLL + HappyPack）。</p><p>页面加载速度其实影响到并不是很大，因为经过 CDN、gzip 后，资源的大小还能接受。这里只是给大家看一些直观的数据变化。6 个月前，打包生成的 app.js 有 5MB（gzip 后 1MB），vendor.js 有 2MB（gzip 后 700KB），app.css 有 1.5MB（gzip 后 250KB）。这样首屏大概要传输 2MB 的内容。拆分后，目前首屏只需要传输 800KB 左右。</p><p>在协作上，我们在全国有三个地方的前端团队，这么多人在同一个工程里开发，遭遇代码冲突的概率会很频繁，而且冲突的影响面比较大。如果代码中出现问题，导致 CI 失败，所有其他人的代码提交与更新也都会被阻塞。使用微前端后，这样的风险就平摊到各个工程上去了。</p><p>再者就是定制化了。我们做的额是一款 toB 的产品，做成 SaaS 标准版产品大概是所有从业者的愿望。但整体市场环境与产品功能所限，经常要面临一些客户要求做本地化与定制化的要求。本地化就会有代码安全方面的考量，最好是不给客户源代码，最差则是只给客户购买功能的源代码。而定制化从易到难则可以分为独立新模块、改造现有模块、替换现有模块。<br>通过微前端技术，我们可以很容易达到本地化代码安全的下限——只给客户他所购买的模块的前端源码。定制化里最简单的独立新模块也变得简单：交付团队增加一个新的微前端工程即可，不需要揉进现有研发工程中，不占用研发团队资源。而定制化中的改造现有模块也可以比较好地实现：比如说某个标准版的页面中需要增加一个面板，则可以通过一个新的微前端工程，同样响应该页面的 URL（当然要控制好顺序），在页面的恰当位置插入一个新的 DOM 节点即可。</p><p>最后就是产品拆分方面的考量了。我们的产品比较大，有几块功能比较独立、有特色。如果说将来需要独立成一个子产品，有微前端拆分作为铺垫，腾挪组合也会变得更加容易些。</p><h2 id="其他目标"><a href="#其他目标" class="headerlink" title="其他目标"></a>其他目标</h2><p>有了以上的一些原因与诉求，在决定进行微前端改造前，还需要设定一些额外的小目标：</p><ul><li>不能对现有的前端开发方式带来太大变化，至少要有平滑过渡的机制。</li><li>每个为前端工程都要求可以独立运行，至少在本地开发时要能做到。</li><li>微前端在加载时，要实现预加载，并可以自由调整预加载顺序，甚至是根据用户的偏好来实现智能化、个性化的加载顺序。</li></ul><h2 id="如何改造现有工程"><a href="#如何改造现有工程" class="headerlink" title="如何改造现有工程"></a>如何改造现有工程</h2><p>“Talk is cheap，show me the code“。下面就让我们一起来看看具体的改造吧！我们的微前端工程可以划分为 portal 工程、业务工程、common 工程这几类。</p><h3 id="portal-工程"><a href="#portal-工程" class="headerlink" title="portal 工程"></a>portal 工程</h3><p>portal，顾名思义，就是入口。这也就是上面所说的微前端加载器。当用户打开浏览器，首次进入我们的页面时，不管是什么 URL，首先加载的就是 portal。portal 里会配置所有业务工程的地址、匹配哪些 URL、需要加载哪些资源。如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务工程的名称</span></span><br><span class="line">customer: &#123;</span><br><span class="line">    <span class="comment">// URL 匹配模式</span></span><br><span class="line">    matchUrlHash: [<span class="string">'^/customer'</span>],</span><br><span class="line">    <span class="comment">// 微前端地址</span></span><br><span class="line">    target: <span class="string">'http://localhost:8101/mfe-customer/index.html'</span>,</span><br><span class="line">    <span class="comment">// 资源匹配模式</span></span><br><span class="line">    resourcePatterns: [<span class="string">'/app.*.css$'</span>, <span class="string">'/vendor.*.css$'</span>, <span class="string">'/manifest.*.js$'</span>, <span class="string">'/vendor.*.js$'</span>, <span class="string">'/app.*.js$'</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>portal 会定时、异步、并发地下载业务工程的资源，并将它们进行注册，此时并不会加载这些业务工程。这里之所以要业务工程的地址（target）、资源（resourcePatterns），是为了加载时确定地知道其所包含的 app.js、vendor.js、app.css 等资源的路径。因为业务工程每次有变更，app.js 等资源路径上都会带有心的文件内容哈希值（Hash），导致路径不可预测。而它的 index.html 的路径是固定的。我们读取该 HTML，解析其内容，通过正则就能匹配到 app.js 等资源的路径。</p><p>portal 在运行时，会监听 URL 变化。目前我们只支持 URL Hash（如 #/customer）。当 Hash 发生变更时，匹配到业务工程，然后执行卸载、加载的工作。这个机制主要是利用 <code>single-spa</code> 来实现，但原理就是这么简单。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; registerApplication &#125; <span class="keyword">from</span> <span class="string">'single-spa'</span>;</span><br><span class="line">registerApplication(<span class="string">'customer'</span>, </span><br><span class="line">    <span class="comment">// 下载微前端工程，获取三个函数钩子：bootstrap、mount、unmount</span></span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> html = fetch(mfeConfig.target);</span><br><span class="line">        <span class="keyword">const</span> &#123;cssUrls, jsUrls&#125; = match(html, mfeConfig.resourcePatterns);</span><br><span class="line">        loadCss(cssUrls);</span><br><span class="line">        loadJs(jsUrls);</span><br><span class="line">        <span class="keyword">return</span> windows[<span class="string">'mfe:customer'</span>];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 对当前浏览器 URL Hash 进行匹配，如果匹配（返回 true），则加载该微前端（调用 mount）；否则卸载（调用 unmount）</span></span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> match(<span class="built_in">window</span>.location.hash, mfeConfig.matchUrlHash);</span><br><span class="line">    &#125;,</span><br><span class="line">    mfeConfig.customProps</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h3 id="业务工程"><a href="#业务工程" class="headerlink" title="业务工程"></a>业务工程</h3><p>业务工程就是普通的微前端工程，一般一个模块一个工程。业务工程要扮演两个角色，一个是可独立运行的前端工程，一个是受 portal 控制的运行时。前者主要用于我们本地开发，后者则是线上集成时使用。在独立运行时，它跟原来的前端工程没有什么区别。以 Vue 工程为例，照样使用 <code>new Vue({el: &#39;#app&#39;})</code> 来启动、渲染页面。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    i18n,</span><br><span class="line">    router,</span><br><span class="line">    store,</span><br><span class="line">    template: <span class="string">'&lt;App/&gt;'</span>,</span><br><span class="line">    components: &#123; App &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>而当受控运行时，则是利用 UMD 方式输出几个钩子函数，包括初始化、加载、卸载。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">window</span>.IS_IN_MFE)&#123; <span class="comment">// 独立运行时</span></span><br><span class="line">    <span class="keyword">new</span> Vue(&#123;...&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 受控运行时</span></span><br><span class="line">    <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">        bootstrap()&#123; <span class="comment">// 注册时执行</span></span><br><span class="line">        &#125;,</span><br><span class="line">        mount(customProps)&#123; <span class="comment">// 加载时执行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Vue(&#123;...&#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        unmount()&#123; <span class="comment">// 卸载时执行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            instance.$destroy()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>线上环境的 Webpack 配置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    libraryTarget: <span class="string">"umd"</span>,</span><br><span class="line">    library: <span class="string">'mfe:customer'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而区分是否受控，则可以通过判断一个全局变量来实现。如 <code>window.IS_IN_MFE</code>，portal 工程在运行时会将其设置为 <code>true</code>。</p><p>为了支持本地多个工程同时开发，我们需要为每个微前端工程指定一个确定的、独占的端口号。比如从 8100 开始，逐一递增。同时，为了支持线上部署，我们还需要给每个微前端工程指定一个确定的、独占的基础路径（前缀）。这样相同域名下可以用不同路径进行独立访问。路径统一以 <code>/mfe-</code> 开头，如 <code>/mfe-customer</code>。这也就是上面 portal 里业务工程的配置示例里所展现的那样。</p><h3 id="特殊业务工程：mfe-navs"><a href="#特殊业务工程：mfe-navs" class="headerlink" title="特殊业务工程：mfe-navs"></a>特殊业务工程：mfe-navs</h3><p>我们产品的页面结构分为顶部栏、侧边栏、中间内容区三大块。顶部栏和侧边栏在页面跳转过程中，基本上保持不变。所以我们也将它们剥离出来作为一个独立的微前端业务工程，叫做 <code>mfe-navs</code>。它会匹配所有的 URL，也就是说访问任意 URL 时，都会加载它，而且还要保证先加载它。当它加载完毕后，会在页面内提供一个中间内容区的锚点 DOM（<code>#app</code>：），供其他业务工程加载时挂载。</p><h3 id="Common-工程"><a href="#Common-工程" class="headerlink" title="Common 工程"></a>Common 工程</h3><p>上面可以看到，每一个业务工程都是一个独立的前端工程，所以里面会有一些相同的依赖，如 Vue、moment、lodash 等。如果将这些内容都打包到各自的 vendor.js 里，则势必会导致代码冗余太多，浏览器运行内存压力增大。我们把这些公共依赖、公共组件、CSS、Fonts 等都放到一个工程里，由该工程进行打包，将依赖、组件 export，并以 UMD 的方式注入到全局。</p><p>main.js：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>; <span class="comment">// 公共依赖</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span>;</span><br><span class="line"><span class="keyword">import</span> VueI18n <span class="keyword">from</span> <span class="string">'vue-i18n'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'@/css/icon-font/iconfont.css'</span>;</span><br><span class="line"><span class="keyword">import</span> ContentSelector <span class="keyword">from</span> <span class="string">'@/components/ContentSelector'</span>; <span class="comment">// 公共组件</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueI18n); <span class="comment">// 大家都要这么做，我们就代劳吧！</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="string">'vue'</span>: Vue,</span><br><span class="line">    <span class="string">'vue-router'</span>: VueRouter,</span><br><span class="line">    <span class="string">'content-selector'</span>: ContentSelector,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>Webpack 配置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    libraryTarget: <span class="string">"umd"</span>,</span><br><span class="line">    library: <span class="string">'mfe:common'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>业务工程则通过 Webpack 外部依赖（external）的方式引入到工程中。这样业务工程打包时就不会包含这些公共代码了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> externalModules = [<span class="string">'vue'</span>, <span class="string">'vue-router'</span>, <span class="string">'content-selector'</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; <span class="comment">// webpack 配置项</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    externals: <span class="function">(<span class="params">context, request, callback</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(externalModules.includes(request))&#123;</span><br><span class="line">            callback(<span class="literal">null</span>, <span class="string">'root window["mfe:common"]["'</span>+request+<span class="string">'"]'</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            callback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上就是我们微前端改造与实践方面的一些经验。前路漫漫，这里面还存在很多待完善的地方，如 History 模式支持、i18n 更好地集成、各个业务工程的加载顺序优化及个性化等。除了这些纯粹技术上的探索，在拥有微前端、微服务这些架构的基础上，团队也可以考虑进行垂直拆分：一个小组独立负责一块业务，它有自己的微前端工程和微服务工程。从技术管理到人员管理，将它们糅合在一起统一考虑，这也是我们软件工程的探索方向。期待这些能够对大家带来一些思考和帮助！</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Coding </tag>
            
            <tag> Frontend </tag>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具利器之 Visual Studio Code（一）</title>
      <link href="/tool-sharp-of-visual-studio-code-1/"/>
      <url>/tool-sharp-of-visual-studio-code-1/</url>
      
        <content type="html"><![CDATA[<p>前面的文章<a href="https://blog.kiliwalk.com/2018/11/23/the-developer-i-want/">《我看开发》</a>中提到要从工具、编码、设计上去提升我们的开发水平。今天我们就先从 Visual Studio Code 这款编程开发软件来看看工具方面的实践。</p><p>Visual Studio Code 是微软推出的一款开源、轻量、跨平台、主要面向 Web 开发的 IDE（集成开发环境）。它是基于 Chrome + NodeJS 这种 Web Hybrid 方案实现的，有别于传统的那些基于本地 Native 开发的 IDE，如 Visual Studio、Eclipse、XCode 等。说得更通俗一点，它其实就是浏览器里的网页。通过这种方式，可以充分利用现有的网页前端开发资源，更加方便进行插件开发与扩展。在这样一款现代、高效的工具面前，有许多值得我们去学习、打磨的地方，以便更加充分地利用它来提高我们的开发工作、甚至是日常工作的效率。  </p><p>下面，我将从 Markdown、快捷键与命令、搜索与替换、正则表达式几个比较重要、提效迅速的方面来说一下。</p><a id="more"></a><h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><p>VSCode 默认将 <code>.md</code> 后缀的文件识别为 Markdown 语言，支持 Markdown 预览。而且它还支持 Markdown inline 渲染，边编辑边渲染，实时检查、展示语法效果。代码工程里经常有各类文档文件，如 <code>README.md</code>、<code>CHANGELOG.md</code>，这样也可以直接在 VSCode 里进行编辑了。<br>同时由于它的轻量、跨平台性，还可以用来做笔记或个人数据管理。推荐大家在 Gitlab.com 上创建一个私有仓库（免费），专用存储自己的工作笔记、个人数据，并使用 VSCode 来管理、编辑，这样既可很方便地做数据同步、又能解决笔记编辑器的问题，不比那些免费或收费的专业笔记软件差。<br>为了保证 Markdown 语法的兼容性，最好确保在编辑 Markdown 文件时，制表符长度为 4 个空格。可以在 User Settings 里按如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;[markdown]&quot;: &#123;</span><br><span class="line">    &quot;editor.tabSize&quot;: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="快捷键与命令"><a href="#快捷键与命令" class="headerlink" title="快捷键与命令"></a>快捷键与命令</h2><p>VSCode 借鉴了很多其他编辑器的优秀快捷键，比如 Sublime Text。利用好快捷键能让我们尽量减少鼠标、触摸板的使用，可以让代码、文档编写工作事半功倍。好用的快捷键很多，但一开始不宜接触太多。我选择了几个效果特别好的给大家介绍下。以下快捷键主要以 MacOS 为例，Windows、Linux 大体相同，但是在 Control、Command 之间存在一些不同，请自行搜索、尝试。  </p><p>选中文本的操作：  </p><ul><li><code>Command + D</code>：选中下一个跟已选中文本相同的文本。比如要选中本文内的所有 <code>Code</code>，则可以先双击选中其中一个，接着一直按 <code>Command + D</code>。每按一次就能选中下一个 <code>Code</code>。此时对某个选中的 <code>Code</code>，可以进行编辑，比如改成 <code>Code It</code>。这样所有已选中的 <code>Code</code> 都会被替换成 <code>Code It</code>。这个命令在我们写代码做重构时特别好用，不用再去用文件内搜索、定位，然后一个一个替换了。</li><li><code>Shift + Command + L</code>：选中所有跟已选中文本相同的文本。跟 <code>Command + D</code> 类似。它特别适合搭配文件内搜索、全局搜索一起使用。当我们想要用正则表达式替换文件内的某些文本，正则匹配好写、正则替换困难或不想写的情况下，可以直接选中所有匹配的文本，直接进行文字编辑。</li></ul><p>行的操作：</p><ul><li><code>Control + J</code>：将下一行合并到当前行，即取消当前行的换行符。连续使用，效果更棒，尤其是想把多行代码合并为一行的时候。</li><li><code>Shift + Command + ↓</code>：“复制”当前行为下一行。它的好处是不会占用系统剪贴板，这样剪贴板里的内容还是可以继续粘贴。</li><li><code>Shift + Command + K</code>：删除当前行。它跟 <code>Command + X</code> 的区别是，后者会将当前行复制到剪贴板再删除。</li><li><code>Command + ↑/↓</code>：移动当前行到上一行前面或下一行后面。</li></ul><p>光标定位：</p><ul><li><code>Control + A</code> 或 <code>Command + ←</code>：定位到行首</li><li><code>Control + E</code> 或 <code>Command + →</code>：定位到行末</li><li><code>Alt + ←/→</code>：定位到前一个词组或后一个词组</li></ul><h2 id="搜索与替换"><a href="#搜索与替换" class="headerlink" title="搜索与替换"></a>搜索与替换</h2><p>VSCode 的文件内搜索与替换很好用，直接 <code>Command + F</code> 就可以唤起搜索。这里我要介绍的是全局搜索。当我们要对多个文件、目录、工程进行文字搜索、替换时，尤其好用。譬如我们要替换多个工程同一个依赖的版本号，可以使用如下方法：</p><ol><li>如果这些工程在同一个目录下，那么使用 VSCode 打开该父目录即可。如果不在，可以开一个新的 VSCode 实例，使用 <code>File-&gt;Add Folder to Workspace</code> 将这些工程加到同一个 Workspace 里</li><li><code>Shift + Command + F</code> 打开全局搜索侧边栏，输入你要检索的文本。</li><li>还可以限定文件。比如只对多个工程里的 package.json 进行查找。此时展开搜索框，在 <code>files to include</code> 里写入 <code>package.json</code> 即可。</li><li>回车开始搜索。VSCode 会在下方展示出所有的匹配内容，以文件为组分隔。</li><li>点击匹配到的内容，则会打开该文件，此时可以进行手动替换。当然，也可以使用全局替换。</li></ol><p>VSCode 最近的更新（1.30.1）也支持多行文本的全局替换了！搜索框内支持回车（但是要按 <code>Shift + Enter</code>），这样多行文本的搜索也很好用了，不能更赞！（想当初我还不得不用 Python 命令行脚本去解决这个需求）</p><h2 id="关于正则表达式"><a href="#关于正则表达式" class="headerlink" title="关于正则表达式"></a>关于正则表达式</h2><p>最后，我想额外提一下正则表达式。正则表达式不仅是编程时可能需要用到，我们正常的文本编辑其实用到的机会会更多，尤其是在进行搜索、替换时。很多人调侃：“正则我每次只要半个小时就会”。的确，简单的正则，如 <code>.*</code>、<code>\d</code>、<code>\w</code>，网上有很多文章介绍使用。甚至一些较为复杂的也能通过谷歌搜索得到。但是之所以能忍受 <code>每次</code> 都花“半个小时”去搜索，就是没有经常使用的缘故。反过来说，如果经常使用，也就不需要花那“半个小时”去搜索了。<br>所以，在进行代码编辑、文档处理或者其他任务时，多使用编辑器提供给我们的正则表达式搜索与替换的能力，会让我们对它自然熟悉。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>VSCode 还有很多地方值得我们深入探索，包括常用插件、工程配置等。它是我们的开发工作、日常工作的效率倍增器，一定要多加思考、多加练习、多加利用。磨刀不误砍柴工。很多时候我们不知道自己的刀快不快，看到别人砍柴快了，也许我们就知道该怎么做了。希望这些技巧能能带动大家“磨刀”的兴趣。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我看开发</title>
      <link href="/the-developer-i-want/"/>
      <url>/the-developer-i-want/</url>
      
        <content type="html"><![CDATA[<p>哪些能力是一位优秀的开发人员在技术上应该具备的？这是一个老生常谈的问题。就像很多人简历里所描述的，“解决问题能力强”、”善于学习“、”积极思考“，以及各种“精通某某某”等。毋庸置疑，能做到这些的人的确可以称得上“优秀”。但我总感觉它们就像散落一地的珍珠，缺少那么一根线来串起来。我想要一个具有提纲掣领的评判依据，甚至在这个纲领下，能够从一种更高的高度去引导我们开发人员的发展方向，更好地帮助他们进行技能学习。在这些年的研发、面试、技术管理工作中，我更倾向于从以下三个角度去认识一位开发人员：工具、编码、设计。<br><a id="more"></a></p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>所谓工具，就是指开发人员对他们用以编程的各种软件、系统，高效率使用、定制化扩展的能力，甚至还包括创造这些辅助软件的能力。马克思曾说，人与动物的区别是制造和使用工具。孔子也有言，工欲善其事，必先利其器。我们不光要使用工具，还要去改进工具，甚至通过工具去制造更加高级的工具。大部分情况下，我们能够做到使用工具，使用一些大众知晓、团队统一的工具。但很多时候，我们对这些工具的使用方式容易形成惯性，对一些没有效率的细节习以为常。即便某些时候，感觉到某些不方便，还是不以为意，不去想是否可以改进。甚至在目前的工具下无法很好、很快地完成某项任务时，我们还会在心里抱怨那些提出这个任务的人。</p><p>为什么会有这些问题存在呢？我想，可能是我们自己都忽视了，软件开发这项工作，可以说是世界上最具灵活性、扩展性的工作了。它可以以成本非常低廉的方式进行自我进化！在我们开发软件的过程中，可以先开发出额外的软件用以帮助我们的开发工作。如此往复，递归推进，没有哪一个行业具备这样的发展方式。身处其中的我们，很有必要认识到这一点。</p><p>所以这里把工具放到第一位，是因为它所表现出来的能力水平，往往可以作为一个开发人员是否”觉醒着“的标记。一个对工具没有认识的人，更可能是一个在开发工作中因循守旧、缺乏生机的人。天花板不高，发展潜力有限。而一个能把工具更高效地利用好的人，相信在接下来的编码、设计方面，也能有更好地表现。</p><p>工具不仅包括跟开发直接相关的部分，如操作系统、IDE、浏览器、命令行、需求管理、版本管理等，还包括日常生活中会使用到的各种软件或服务，如即时通讯、日程管理、邮箱、文件管理、翻译等。除了这些已有的软件或服务外，对一些通用的功能概念也要烂熟于心，如正则表达式、通用文本编辑快捷键等。再者就是对于需要再造工具的场景，要会使用一些脚本语言自行编写，如 Bash、Python、JavaScript。这些脚本语言的运用，自然也需要在编码上下一番功夫。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>编码，这大概是开发人员觉得自己最有把握的事情了。编码不就是把功能需求用一门高级语言实现出来嘛！实现的细节不就是各种 if、for、赋值等语句的组装嘛！而且，最终用户可能只关心整个系统的功能是否正常，他们不会关心内部是怎样去实现的。“功能正常”，这既是最高的要求，却往往也是最低的要求。作为开发者，要认识到仅仅让功能正常也许比较简单，但实现时粗糙的编码可能会藏有各种难以发现的问题。这样在某一时刻或情景下，“功能正常”也就无法保证。就像《The Art of Computer Programming》这本书名所表示的那样，如果我们把编程当做一门艺术，抱着雕琢自己作品的态度去面对代码，就不会仅仅只局限于它的外在，而不在乎其内在了。</p><p>然而在编码这件事上，很多人又容易走极端，极尽所能地去研究那些奇技淫巧，甚至以此作为炫耀的资本。比如利用运算符优先级编写极其复杂的计算表达式、利用语言特性实现极其难以理解的逻辑。每一门语言都有一些犄角旮旯的特性，甚至有所不足或缺陷。但在我们正常的开发工作中，应该尽量去避免触碰这些陷阱。把那些绕脑的、存在歧义的语法与写法通通扔掉。多去研究那些更加现代、安全、人性化的表达方式。</p><p>好的编码，首先风格就很不一样。一个具有良好目录组织结构的工程、一段具有良好命名的代码，都会让人看起来赏心悦目、心旷神怡。然后就是对语言层面各种语法要运用自如。对各种高级语法的底层实现要抱有一颗求索的心，甚至由此追溯到汇编、机器码乃至计算机硬件。还有安全性、性能、扩展性等各个方面。而后面这些，其实就已经上升到设计层面了。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>那什么是设计呢？如果把编码看做”行（xíng）“，那么设计就是”思“。行成于思毁于随，还要三思而后行。”思“，首先要从业务、产品的高度上进行求证：这个功能它的目的是什么？它的工作场景是什么？它有无存在的必要或者改善的可能？其次就是从使用者的角度换位思考：如果我是用户，我需要的是什么？我会如何去做某件事？我完成的效率能否提升？最后就是我们的技术上考量：数据结构该如何去设计？如何应对可能的修改？如何保证程序的健壮性？如何应对高并发的场景？等等，不一而足。良好的设计能够让我们规避代码修改的泥淖、跳过未知缺陷的深渊。</p><p>希望通过工具、编码、设计这么一根准绳，穿入我们日常的开发工作中，能够让我们时刻保持清醒、明确的研究思路，握紧发展的方向舵。祝愿大家！</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Coding </tag>
            
            <tag> Think </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Turn over a new leaf</title>
      <link href="/turn-over-a-new-leaf/"/>
      <url>/turn-over-a-new-leaf/</url>
      
        <content type="html"><![CDATA[<p>时隔近十年，心里又重新动起了写点文字的念头。倒不是说要达到著书立说的高度，而是觉得把东西公开写出来，比自己私下做些日记或笔记会更多一点东西。在一定程度上，它可以促使我以更加严谨地态度去对待经验。虽然是我个人的经验，但可能对别人也会有一些用，满足一下虚荣❤。<br><a id="more"></a></p><p>作为一个 Web 开发程序员，技术肯定会比较多地谈及。但互联网上已经有千千万万地技术分享、讨论，重复或原创，应接不暇。而我的初心，绝不想做完全重复的事情–像所谓布道士一样去无限强调某种东西来做宣传。我所要谈的内容，只是代表我自己，抑或可能存在的某一些人，以某种思维方式去理解的技术。也许比较粗浅，甚至存在错漏，但没关系，至少它描绘了我学习、成长的轨迹。</p><p>除了技术上的内容，偶尔可能还会夹杂一些“无聊”的东西，譬如随想、生活经验、音乐分享之类。总而言之，这个博客，它将不存在一个明显的主线：零零碎碎，甚至杂乱无章。但是这些我选择发表出来的东西，它们构成了一个一个重要的时间节点。若干年后，当我回顾时，这便是我的人生学习轨迹！乃至激励我：人生不止，奋斗不息！</p>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Misc </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
