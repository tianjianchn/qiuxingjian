<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>戏说网络（二）</title>
      <link href="/network-joking2/"/>
      <url>/network-joking2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.kiliwalk.com/network-joking/">上一篇</a>我们聊到了从最原始的两个人的连接需求到多个人的连接需求，进而衍生出了 MAC 地址、交换机等网络概念。今天我们来继续瞎聊。</p><h2 id="交换机互联"><a href="#交换机互联" class="headerlink" title="交换机互联"></a>交换机互联</h2><p>当要连接的人越来越多，超过 10 个、20 个、30 个、50 个，我们的一个交换机也没有那么多网口了。聪明的同学肯定想到了，交换机连交换机。每个交换机上连接 10 来个人，来几个交换机就能连接几倍的人数。<a id="more"></a>假设 A、B 接在交换机一的 1、2 网卡上，C、D 接在交换机二的 1、2 网卡上，交换机一和二的 3 号网卡互相连着。则经过若干次广播之后，交换机一的 MAC 地址表会是这样：</p><table><thead><tr><th style="text-align:center">MAC</th><th style="text-align:center">网卡号</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">3</td></tr></tbody></table><p>交换机二的 MAC 地址表会是这样：</p><table><thead><tr><th style="text-align:center">MAC</th><th style="text-align:center">网卡号</th></tr></thead><tbody><tr><td style="text-align:center">C</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">A</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">3</td></tr></tbody></table><h2 id="广播风暴"><a href="#广播风暴" class="headerlink" title="广播风暴"></a>广播风暴</h2><p>那么要经过多少次广播呢？广播又会有什么不一样呢？假设当地址表都是空的时候，A 要给 B 发送数据。此时地址表里找不到 B，于是交换机一开始广播。广播的数据也会通过 3 号网卡到达交换机二。交换机二里也是空的，也没有 B，于是又在交换机二里广播。所以 A 给 B 发送数据会导致交换机一、二都发生广播。接下来 A 给 C 发送数据，交换机一地址表没有 C（此时只有 A 和 B），所以又要广播。同样交换机二也要广播。我们可以把所有情况都列下来：</p><table><thead><tr><th style="text-align:center">通信方向</th><th>交换机一广播</th><th>交换机二广播</th><th>通信后交换机一地址表</th><th>通信后交换机二地址表</th></tr></thead><tbody><tr><td style="text-align:center">A-&gt;B</td><td>广播</td><td>广播</td><td>A、B</td><td>A</td></tr><tr><td style="text-align:center">A-&gt;C</td><td>广播</td><td>广播</td><td>A、B、C</td><td>A、C</td></tr><tr><td style="text-align:center">A-&gt;D</td><td>广播</td><td>广播</td><td>A、B、C、D</td><td>A、C、D</td></tr><tr><td style="text-align:center">C-&gt;D</td><td></td><td></td><td>A、B、C、D</td><td>A、C、D</td></tr><tr><td style="text-align:center">C-&gt;B</td><td>广播</td><td>广播</td><td>A、B、C、D</td><td>A、B、C、D</td></tr></tbody></table><p>有没有发现？任何一个交换机的广播，都可能导致连接的另一个交换机也产生广播？广播被逐级放大。互联的交换机越多，在每个交换机产生的广播就越频繁。正常的数据发送通道就被广播给占用了，导致网络不堪重负。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>也许有的同学会有疑问，也就是当地址表中没有对应项时才会发生广播，当每个交换机都有了整个网络的所有地址后，也就不会再有广播了。的确是！但这是建立在网络很稳定的基础上。如果 A 拔了网线换成 E 呢？如果 A 跟 C 交换了位置呢？所以地址表不能一成不变，它必须要适应这种变化。也就是说，我们要在必要的时候刷新它们。最简单的做法，就是定时清除地址表里的记录了。也可以说，地址表仅仅就是一种缓存，并不是永久存储。而且缓存的时间一般不会太长，可能也就几秒到几十秒，避免位置变化导致用户无法通信。</p><h2 id="更大的连接"><a href="#更大的连接" class="headerlink" title="更大的连接"></a>更大的连接</h2><p>这样来看，广播的频率还是比较高。这就限制了通过交换机互联的网络，不宜过大。这样几十人一个交换机网络，就形成一个一个的网络小孤岛。其实也挺好，大家在各自的网络小空间里，悠然自得。但什么事都怕时间二字。时间长了，总会觉得腻的，毕竟外面的世界那么大，谁都想去看看。可我们已经不能用交换机了。怎么办？在找到办法之前，先来看看我们面临的问题：</p><ul><li>不能再任由广播风暴产生了</li><li>小网络圈子里太随意，地址随意填。这样网络对接时，大家使用的地址就可能有冲突</li><li>甚至这个小网络里，大家使用的协议都不一样，有的网络里用的可能并不是 MAC 地址</li><li>将来要连接的网络还会更多，不能任意填写地址了，必须有专门的管理方式</li></ul><p>还有没有其他问题？大家可以先想想。下一篇我们来聊聊解决办法。</p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>戏说网络（一）</title>
      <link href="/network-joking/"/>
      <url>/network-joking/</url>
      
        <content type="html"><![CDATA[<p>最近工作中需要使用 LVS 负载均衡，而运维告知后端主机所在网段不匹配，可能无法申请。抱着好奇的心理，就去研究了下 LVS。然而网上的文章要么过于粗略，要么还是有一些细节让我百思不得其解。尤为让我疑惑的就是网络数据包的处理与分发。于是重温了有关 NAT、交换机、网关、路由等一系列相关网络概念，查阅各路大 V 的文章。最后在一个评论中不经意看到一本好书：《网络是怎样连接的》，完美地把目标从 LVS 转为了计算机网络😝。</p><p>这本书讲述的内容，其实跟我以前面试时很喜欢问的一个题目很类似：当你在浏览器里输入一个 URL 会发生什么。这个问题我只用过一段时间，后来就搁置了。当然了，这里主要考验的方面在于服务端以及前端的处理逻辑，跟底层网络的关系倒并不深究。而这本书则着重讲解了网络底层的处理流程，包括各种网络协议、网络设备、信号处理、操作系统 IO 处理等。推荐大家去读一下，能让你对网络有一个更形象化的认识，让你的认识更有层次逻辑。我也打算就本书做一些读书笔记，浓缩一下书中内容（毕竟 300 多页的书），以一个门外汉（Layman）的视角讲述下这里面的内容。<br><a id="more"></a></p><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>网络的目的，就是为了连接。最开始的需求可能是两个人的计算机要连接，互相传递数据。那么每个人的计算机里就各需要有一种设备，可以用来发送和接收数据。这个设备就是网卡。用一根线把这两张网卡连接起来，双方就可以通过信号进行通信。这根线就叫网线。</p><p>两个计算机的通信很简单，A 要给 B 发送什么数据，就构造好数据直接让网卡发出去就行，不需要问怎么到达，也不可能会丢。不过两个人聊天就是会有聊完的时候，不如加一个人一起唱戏。于是第三个人的计算机就加入进来了。那怎么连接这三个计算机呢？可以考虑让一个计算机做中继。像 A<->B<->C 这样由 B 来中继，A 要给 C 发送数据，就先发给 B，然后 B 转给 C。所以 B 上面就得有两张网卡。可是这还不够，B 怎么知道 A 发过来的数据是给自己的还是给 C 的？这里我们就需要确定各自的标识了。这种标识我们就把它叫做地址。当 A 要给 C 发送数据时，数据里额外增加一项地址，填 C，然后由 A 的网卡发出去。所以传送的数据其实是由两部分构成的，一部分是地址，一部分是真正的有效数据。地址一般放在头部，可以更快地提取出来进行识别。B 左侧的网卡（跟 A 相连的）收到后，检查数据头部的地址，发现是给 C 的，不是给自己的。那么它该用哪张网卡来发呢？肯定不能用左侧的网卡了，不然 C 就收不到了。所以左右两张网卡都要有一些标记，表明自己可以通往哪里。这就是地址表。像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 地址 | 网卡     |</span><br><span class="line">| ---- | -------- |</span><br><span class="line">| A    | 左侧网卡 |</span><br><span class="line">| C    | 右侧网卡 |</span><br></pre></td></tr></table></figure></-></-></p><p>这时，B 就知道要用右侧网卡转发数据了，这样 C 就收到了 A 发送的数据。</p><p>三个人唱戏也唱累了，想打麻将了，又拉来了 D。这个时候怎么办？也许我们可以继续串行地连起来：A<->B<->C<->D。但是这样链条有点长，A 可能就不愿意跟 D 玩。还有一种方式像星状一样连接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A&lt;-&gt;B&lt;-&gt;C</span><br><span class="line">    ↕</span><br><span class="line">    D</span><br></pre></td></tr></table></figure></-></-></-></p><p>A 跟 C 和 D 之间的通信，都经过 B。这里 B 就有了 3 张网卡。接下来可能还会有第五个、第六个人加入。B 可能就不太愿意了，凭什么在我身上插满了网卡？那么多数据到我这，真正给我的只有占很少一部分，这种感觉一点也不好。大家觉得也是，的确委屈 B 了。那我们把转发这种功能单独抽取出来如何？</p><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>这种只做网络数据转发的设备，我们就把它叫做交换机。它上面有多个网卡，能够根据地址表转发数据。而 A、B、C 等的网卡地址，专业术语就叫 MAC。MAC 地址由 6 个字节构成，用 16 进制表示就类似 00:00:00:00:00:00。有了 MAC 和交换机，我们就能够让所有接入交换机的计算机彼此进行通信。这就是我们整个网络中的数据链路层，也就是常说的第二层（第一层是物理层，即数字信号或模拟信号传输）。第二层传送的数据包由 MAC 头部和数据块构成。MAC 头部包含发送方的 MAC 地址（来源 MAC）和接收方的 MAC 地址（目的 MAC）。  </p><p>那么在一个有交换机连接的网络里，各个计算机之间如何通信呢？假设有 4 台计算机 A、B、C、D。其中 A 和 B 各有一张网卡，MAC 地址分别是 00:00:00:00:00:AA、00:00:00:00:00:BB。然后它们分别连接到交换机的网卡 1、网卡 2 上。此时交换机里还没有任何地址表，也不需要手动维护地址表。A 要给 B 发送数据，则要填写 B 的 MAC 地址。A 构造数据包，来源 MAC 填写 00:00:00:00:00:AA，目的 MAC 填写 00:00:00:00:00:BB，通过 A 的网卡发送给交换机。交换机从与 A 连接的网卡 1 都收到一个数据包，解析来源 MAC 地址，此时就把 MaC 地址 A 与 网卡 1 写入地址表。此时地址表为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| MAC 地址          | 交换机网卡号 |</span><br><span class="line">| ----------------- | ------------ |</span><br><span class="line">| 00:00:00:00:00:AA | 1            |</span><br></pre></td></tr></table></figure></p><p>接着解析目的 MAC 地址，得到 00:00:00:00:00:BB。但是地址表中没有该地址的记录，交换机不知道该从哪个网卡转发出去数据包。于是交换机就把数据包转发到它自己的所有网卡，除了来源网卡（即网卡 1）。这就叫广播。这样 B、C、D 都会收到该数据包。它们的网卡在收到数据包后，会解析出目地 MAC。其中 C、D 发现跟自己的 MAC 地址不一样，直接丢弃（它要是不丢而是要偷窥怎么办？那么没办法，这就是网络安全地范畴了）。B 发现是发给它的数据包，就接收并处理了。接着 B 回复数据给 A。跟上面的流程类似，交换机收到数据包后会往地址表里增加新的一项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| MAC 地址          | 交换机网卡号 |</span><br><span class="line">| ----------------- | ------------ |</span><br><span class="line">| 00:00:00:00:00:AA | 1            |</span><br><span class="line">| 00:00:00:00:00:BB | 2            |</span><br></pre></td></tr></table></figure></p><p>由于目标地址是 00:00:00:00:00:AA，在交换机地址表里存在，此时就不需要做广播了。</p><p>这样一个小网络就成型了。接下来要接入的人越来越多，数据包也越来越多。我们还想跟遥远的别的人群进行通信。这会不会有问题呢？如果会，又会有哪些问题呢？不妨先想想，后面我们再来看看。</p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员笔记（知识）管理的一点经验</title>
      <link href="/coder-notes-management/"/>
      <url>/coder-notes-management/</url>
      
        <content type="html"><![CDATA[<p>记笔记这件事，也许在很多人看来，再普通、简单不过了——从小老师就教育我们要这么做。不同的人有不同的方式，我们最终的目的，还是希望不要停留在只是记录这一层面上，而是将它们转变为我们的知识。作为一个程序员，今天我跟大家聊聊我的一些笔记管理的方法，希望对大家有用。如果大家还有更好的方式，也欢迎留言一起探讨。</p><h2 id="知识学习的路径"><a href="#知识学习的路径" class="headerlink" title="知识学习的路径"></a>知识学习的路径</h2><p>首先聊聊知识学习的路径。讲得宏大一点，我们得先有方法论。知识学习的途径可以分为以下几个阶段：<br><a id="more"></a><br><img src="/images/coder-notes-path.png" alt=""></p><p>接触，可能来源于工作中遇到的一个问题，或者朋友的推荐，或者逛社区、论坛时看到的新鲜内容。在接触之前，我们并不知道，或者并不在意一个知识的存在，以及它是如何存在的。通过接触，它勾起了我们的好奇心，激发了我们的热情，吸引我们去实践。</p><p>实践，就是依照别人所描述的内容，或者自己个人的理解，动手去解决问题。只有经历过实践，才能摸清楚细节，才能更加具象、深刻地理解某项知识。而在实践的过程中，我们可能会遇到各种状况，别人未描述的或自己不甚理解的。通过各种其他手段，如查阅、咨询等，最终解决了问题，丰富了知识适用的场景及其内涵。然后我们就需要把实践的过程记录下来，形成我们自己的认知。</p><p>总结，就是用自己的话去描述同样一个知识。它的表述形式可能跟别人的不一样，关注的细节点也可能不一样。通过总结，形成我们认识事物的方式。这种方式继而会影响我们在后续的实践过程中的工作流程。一些较复杂的知识点也不是一次实践或总结就能准确理解的，也许有疏漏。在后续的工作、学习中，我们使用这些尚未完全的知识，遇到困难，又继续总结，形成一个反馈循环。直到达到一个较为满意的状态。这个时候，我们就可以考虑“为人师”了。</p><p>分享，就是把自己掌握的知识，用更多人能理解的方式讲述、传播出去。它跟总结的区别就是，不再是仅仅以个人能理解的方式去表达知识，而是要辅以通俗的语言、合适的图文来表达。让大家看到还有这样一种角度、思路，成为他们的知识接触点。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>这里我们讨论的知识的主要载体，就是笔记。根据知识学习的路径，我们可以对笔记进行分门别类。至少要单独列出分享这一目录。我常用的一级目录为：</p><ul><li>分享：包含所有待分享或已分享的文章、素材，使用日期作为子文件夹或文件名前缀。</li><li>开发：包含开发相关的知识点，如语言、工具、操作系统、网络、中间件、架构等等</li><li>工作：包含各个公司、个人项目的工作内容与日常记录</li></ul><p>至于一级目录以下的目录划分，可以根据每个人所侧重的知识面来安排。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>那用什么做笔记呢？市面上已经有很多笔记管理软件了，像 EverNote、有道等。不过作为程序员，我们手边的开发工具就能做笔记管理。这里我推荐用 Visual Studio Code。它是一款非常轻量的 IDE 工具，有强大的插件体系。它不光可以用来写代码，还可以用来写文档，尤其是 Markdown 文档。自带 inline 样式渲染，支持格式校验、自动排版（尤其是 table）、PDF 导出等各种功能，还有很多插件可供你选择。</p><p>Markdown，我想每个程序员都应该熟悉它的语法。其实核心的、常用的几个语法很简单，包括多级标题、多级列表、Code 等。像我写这一篇文章，用到的也就无非这些语法点，额外多了图片的插入等。根本不需要花多少时间。但是掌握它，不光有助于我们写文章，包括开发中写文档，都是非常有用的。像我们常用的 Github、Gitlab 里，都可以直接渲染 Markdown 文件，Issue 中也能支持 Markdown 语法。学会一招，吃遍天下。很有必要。</p><p>也许有的同学会有疑问，那岂不笔记都是本地存储了？这个问题很好。我们还需要一些工具，Git + Gitlab。将整个笔记目录加入 Git 版本控制，这样我们所有的笔记历史都能保存起来。然后，我们可以在 Gitlab.com 的个人账号上创建一个私有项目，同步我们的本地笔记到远端。这样，我们在公司使用公司的电脑，可以顺利地同步；手机端也可以使用浏览器访问 Gitlab 网址在线打开我们的项目，查看笔记。有了 Git 支持，即便多端修改产生冲突，也能很好地去解决。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>用 VSCode + Gitlab 来管理我们的笔记，还有一个好处就是，这些笔记就是我们看得到的文件。那这里我们可以引申一下。把我们的笔记管理作为个人知识仓库，它里面还能包含各种可以执行的脚本（如 Bash、Python）。这些脚本是我们自己编写的、用来方便我们工作的。比如说我就写了很多类似 Git 周报、Gitlab CI 自动化等这样的脚本。它们不光能在我家里的电脑上执行，还能同步到我公司的电脑上，照样执行。而且执行的方式不会有什么变化，不需要额外下载、保存、授权等各项工作，这些都在同步过程中解决了。十分方便。</p><p>当然，以上方式也有一些弊端，比如图片不好处理，无法直接粘贴到文章里（也许有这样的 VSCode 插件呢？）。不过至少我个人用起来，还是很舒服的。也希望这些内容，能为大家产生一些”接触“点。</p>]]></content>
      
      
      <categories>
          
          <category> Management </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Think </tag>
            
            <tag> Management </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提升 Visual Studio Code 的 JavaScript 开发效率（三）—— JSDoc</title>
      <link href="/vscode-javascript-project-3/"/>
      <url>/vscode-javascript-project-3/</url>
      
        <content type="html"><![CDATA[<p>前面我们讲了 jsconfig.json 和 Go To Definition 相关内容，现在 JavaScript 的开发已经非常像在传统 IDE 里做静态、编译类型语言的开发体验了。今天我们就再来突破一下，把”静态类型“也加入到 JavaScript 中去！而这，关键就是 JSDoc（<span class="exturl" data-url="aHR0cDovL3VzZWpzZG9jLm9yZy8=" title="http://usejsdoc.org/">http://usejsdoc.org/<i class="fa fa-external-link"></i></span> ）。<br><a id="more"></a></p><h2 id="JSDoc"><a href="#JSDoc" class="headerlink" title="JSDoc"></a>JSDoc</h2><p><img src="/images/vscode-jsdoc-example.png" alt=""></p><p>JSDoc 本身是用来对方法、变量、模块、类等进行结构化文档注释用的。它本身还有一个对应的工具，扫描所有源代码文件里的 JSDoc 注释并生成 API 文档，就像 JavaDoc 一样。</p><p>但是在 VSCode 里，它被赋予了更加强大的地位。它不仅仅是一个文档说明，还可以用来做智能提示（IntelliSense），而且可以做到函数的参数级别。甚至还能做参数类型、值类型的校验！也许你会想到 TypeScript 的 definition 文件（.d.ts）。是的，它也有参数类型校验，但是它没有参数说明。如果要参数说明，还是要写 JSDoc。与其多写一遍 definition，不如直接使用 JavaScript + JSDoc 更加方便。当然这一切都是依赖于 TypeScript，我们不能因此去否定它。</p><p>我们来看看 JSDoc 所带来的强大提示功能。<br><img src="/images/vscode-jsdoc-intelli.gif" alt=""></p><p>从上面的动图可以看到，函数的注释、参数的注释、参数注释的输入跟随都有了。</p><h2 id="参数、类型校验"><a href="#参数、类型校验" class="headerlink" title="参数、类型校验"></a>参数、类型校验</h2><p>文档提示只是第一步。我们知道 JavaScript 是动态类型、弱类型的语言。变量没有类型声明，运行时还可以随意变更值类型，还有很多内置的自动类型转换场景。虽然这是吸引我的很大的一方面，不过在团队协作里，最好还是能够做到约束、检查一下。VSCode 就为我们提供了这么一个能力。</p><p>首先我们要打开 Setting 中的 JavaScript 校验：<code>&quot;javascript.validate.enable&quot;: true</code>。然后在 jsconfig.json 中配置如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">      <span class="attr">"checkJs"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们再来看看：<br><img src="/images/vscode-jsdoc-check.gif" alt=""></p><p>是不是很不错？VSCode 帮我们做了必填参数、参数类型、返回值类型等各项检测与校验。这样我们在写代码的时候，一方面能够看到文档注释，一方面又能随时知道调用方式是否错误，快哉！</p><h2 id="对象解构形式参数"><a href="#对象解构形式参数" class="headerlink" title="对象解构形式参数"></a>对象解构形式参数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * set redis key</span></span><br><span class="line"><span class="comment"> * @author kiliwalk</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; params the parameters</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; params.key redis key name</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; params.value redis key value</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; [params.expire] redis key expire time(seconds)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">&#123;key, value, expire&#125;</span>)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上示例，我们使用了 Object Destruction 定义了方法的参数。对应的，JSDoc 里可以通过 <code>.</code> 来为对象内部的属性提供文档。来看看使用时的效果：</p><p><img src="/images/vscode-jsdoc-object-destr.gif" alt=""></p><p>这里有一个地方要注意，参数文档那一个小窗口，如果一开始没有显示，则要再按一次 <code>ctrl+space</code>（macOS），也就是额外触发一次智能提示。这个在 VSCode 里叫“toggleSuggestionDetails”（可以在快捷键设置里找到它）。</p><p>VSCode 里还支持更加复杂的 JSDoc 类型声明。在涉及到复杂对象的输入、输出时，我们可能就需要用到了。有兴趣的同学可以去这里看看：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L3dpa2kvSnNEb2Mtc3VwcG9ydC1pbi1KYXZhU2NyaXB0" title="https://github.com/Microsoft/TypeScript/wiki/JsDoc-support-in-JavaScript">https://github.com/Microsoft/TypeScript/wiki/JsDoc-support-in-JavaScript<i class="fa fa-external-link"></i></span> 。</p><p>希望通过这几篇文章，能够改善大家日常的 JavaScript 开发体验。这里面还有很多东西值得我们去探索。</p><p>现在，有没有感觉在 VSCode 里开发 JavaScript 完全是另一番体验？</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何提升 Visual Studio Code 的 JavaScript 开发效率（二）</title>
      <link href="/vscode-javascript-project-2/"/>
      <url>/vscode-javascript-project-2/</url>
      
        <content type="html"><![CDATA[<p><a href="">上一篇</a>我们介绍了在 Visual Studio Code 引入 jsconfig.json 文件来提升 JavaScript 的开发效率。jsconfig.json 是基础，有了它才有后续的功能增强。今天我们就来看看在它的基础上，如何增强在模块引入、点击跳转等的使用体验。</p><h2 id="import-路径提示、补全"><a href="#import-路径提示、补全" class="headerlink" title="import 路径提示、补全"></a>import 路径提示、补全</h2><p>虽然我们在使用 VSCode 的 IntelliSense 时——比如自动补全一个源代码内的函数，它能帮我们自动 import 函数所在文件。但是对于 NodeJS 内置的模块（如 path、fs、util 等）、package.json 中的 dependencies 等所包含的函数，必须先手动 import 进来才能进行提示。为了让手写 import 更加快捷，这里我们就需要安装一款 VSCode 插件：<a id="more"></a>Node.js Modules Intellisense。它集成了 NodeJS 内置模块、dependencies、devDependencies、源代码文件模块的扫描与提示。<br><img src="/images/vscode-js-import-intelli.gif" alt=""></p><h2 id="import-绝对路径"><a href="#import-绝对路径" class="headerlink" title="import 绝对路径"></a>import 绝对路径</h2><p>默认情况下，我们只能使用相对路径来引入文件。如果项目层次比较深的时候，就会出现 <code>import &#39;../../../xxx.js&#39;</code>。这么长的相对路径，无法一眼看出其真实位置，这样就比较容易出现引入错误的问题。我们希望这里能够引入绝对路径——当然是相对工程根目录的”绝对路径“，像 <code>import &#39;lib/util.js&#39;</code>。</p><p>首先，可以设置 jsconfig.json 的 baseUrl：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">      &quot;baseUrl&quot;: &quot;./src&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样自动引入或手动引入都可以使用绝对路径。<br><img src="/images/vscode-js-import-abs.gif" alt=""></p><p>但是这样的引入在运行时会报找不到文件，因为它并非 dependencies。有两个办法可以解决，一是在 babel build 的时候，把路径进行补全，这个可以利用 babel-plugin-module-resolver 来解决。或者不补全路径，直接设置 NODE_PATH 到 baseUrl 所指向目录，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须是第一个加载的文件</span></span><br><span class="line">process.env.NODE_PATH = __dirname; <span class="comment">// __dirname 替换为 baseUrl 所对应目录</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'module'</span>).Module._initPaths();</span><br></pre></td></tr></table></figure></p><h2 id="Go-To-Definition"><a href="#Go-To-Definition" class="headerlink" title="Go To Definition"></a>Go To Definition</h2><p>有了 import 路径自动补全的支持，我们就可以使用 <code>Go to definition</code> 功能了。按住 <code>Cmd</code> 键（Windows 上用 Ctrl）并使用鼠标单击 import 的路径部分，就可以跳到目标文件。但是我们发现，如果 import 的是 .json 文件或 .jsx 文件，是无法进行跳转的。右键路径并点击 <code>Go To Definition</code> 会提示 <code>No definition found for xxx</code>。</p><p>这个时候我们就要用到更加复杂的配置了。由于 JavaScript 工程在 VSCode 里是 TypeScript 工程的子集，它的很多功能都是由 TypeScript 提供。相应地，jsconfig.json 也是 tsconfig.json 的子集。在 tsconfig.json 的 schema（<span class="exturl" data-url="aHR0cDovL2pzb24uc2NoZW1hc3RvcmUub3JnL3RzY29uZmln77yJ6YeM77yM5oiR5Lus5om+5Yiw5LqG55u45YWz6YWN572u6aG577ya" title="http://json.schemastore.org/tsconfig）里，我们找到了相关配置项：">http://json.schemastore.org/tsconfig）里，我们找到了相关配置项：<i class="fa fa-external-link"></i></span><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">      <span class="attr">"jsx"</span>: <span class="string">"react"</span>,</span><br><span class="line">      <span class="attr">"moduleResolution"</span>: <span class="string">"node"</span>,</span><br><span class="line">      <span class="attr">"resolveJsonModule"</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/vscode-js-go-to-def.gif" alt=""></p><p>以上使用 import 的地方，同样也适用传统的 commonjs（require）语法。接下来，我们将会聊聊更令人兴奋的功能：让 JavaScript 也具有静态类型检查、校验的能力——可不是 TypeScript 或 Flow 哦。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何提升 Visual Studio Code 的 JavaScript 开发效率（一）</title>
      <link href="/vscode-javascript-project-1/"/>
      <url>/vscode-javascript-project-1/</url>
      
        <content type="html"><![CDATA[<p><a href="">前面</a>我们介绍了 Visual Studio Code 各种基础能力，包括常用快捷键、全局配置（User Setting）等内容。我们还没怎么谈到插件、工程方面的运用。虽然现在 VSCode 已经支持多种语言，如 Python、PHP，甚至 Java、C/C++。但作为其最早支持的语言，也是我最喜欢的编程语言——JavaScript，尽管它的弱类型、动态类型等特性在以前是 IDE 的灾难，但是在 VSCode 里，这不再是问题。</p><h2 id="jsconfig-json-文件"><a href="#jsconfig-json-文件" class="headerlink" title="jsconfig.json 文件"></a>jsconfig.json 文件</h2><p>默认情况下，不需要我们做任何额外配置，VSCode 就已经为 Workspace 内的 js 文件提供了 JavaScript 方面的支持，包括 IntelliSense（智能提示）、Snippets（代码片段）、Debug（调试）、Format（格式化）、Validate（校验）等。但是在以下场景，我们就需要一个叫 jsconfig.json 的文件了：</p><ul><li>一个 Workspace 中有多个工程，比如前端、后端工程。IntelliSense 应该以工程边界，而不要跨工程提示。</li><li>使用非相对路径方式的导入工程内的文件，如 <code>import &#39;lib/util.js&#39;</code>，而不是 <code>import &#39;../../lib/util.js&#39;</code>。<a id="more"></a>就像 package.json 表示所在目录是一个 NodeJS 工程，jsconfig.json 表明这个目录是一个 VSCode JavaScript 工程。当然，jsconfig.json 还有很多其他作用，善用它能够极大提升我们的开发效率。因此，即便 Workspace 本身就是一个工程，我们也要在它的根目录下提供这么一个文件。</li></ul><h2 id="IntelliSense-工程隔离"><a href="#IntelliSense-工程隔离" class="headerlink" title="IntelliSense 工程隔离"></a>IntelliSense 工程隔离</h2><p>我们先来看看 jsconfig.json 带来的 IntelliSense 按工程隔离的特性。如下图所示，当前 Workspace 里有 frontend、backend 两个 Project。每个 Project 下都有一个 xxx_util.js，里面都包含了一个 <code>isOdd</code> 方法——注意，它们的注释不一样。</p><p><img src="/images/vscode-js-multi-projects.png" alt=""></p><p>当我们在的 backend 工程下的 index.js 文件里输入 <code>isO</code> 时，IntelliSense 展示的是 backend 工程下的那个 <code>isOdd</code> 方法（注释是 <code>check number is an odd integer in backend</code>），而不会提示 frontend 工程里的。</p><p><img src="/images/vscode-js-multi-projects-intelli.png" alt=""></p><p>当我们继续按 Enter 或 Tab 键以确定后，IntelliSense 会在 index.js 文件的顶部自动加入 <code>import { isOdd } from &quot;./backend-util&quot;;</code>。是不是很赞？对一个全栈开发或<a href="https://blog.kiliwalk.com/micro-frontend-practice/">微前端</a>开发者来说，往常多个工程同时打开导致 IntelliSense 里有重复项的烦恼就一去不复返了。</p><h2 id="排除工具、中间代码"><a href="#排除工具、中间代码" class="headerlink" title="排除工具、中间代码"></a>排除工具、中间代码</h2><p>IntelliSense 工程隔离的问题解决了，接下来我们来看一个工程的内部。在一些比较复杂的工程里，可能包含很多非源代码（src）的目录，如 bin、test，还有编译后的 dist 目录等。默认情况下，这些目录下的 js 文件都会被 IntelliSense 解析，从而出现在源代码的提示里。这一方面会造成重复提示，另一方面也会严重拖慢 IntelliSense。一般我们都会把源代码放到 src 目录，所以我们只需要在 jsconfig.json 中增加配置 <code>&quot;include&quot;: [ &quot;src/**/*.js&quot; ]</code> 即可。</p><h2 id="限定-ES-版本"><a href="#限定-ES-版本" class="headerlink" title="限定 ES 版本"></a>限定 ES 版本</h2><p>除了源代码内的模块及其引用（Reference）可以被用于提示，VSCode 还内置了 ES、DOM、NodeJS 库的 API 引用，即 TypeScript 的 lib.d.ts 文件。当我们需要使用内置 API 的时候，IntelliSense 就能提示它们了。VSCode 还可以让我们配置要使用哪个版本的 lib.d.ts。如果用的是 node 10，则可以使用 es2018：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">      <span class="attr">"target"</span>: <span class="string">"es2018"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其他版本的 Node 对应的 ES 版本，可以在 <span class="exturl" data-url="aHR0cHM6Ly9ub2RlLmdyZWVuLw==" title="https://node.green/">https://node.green/<i class="fa fa-external-link"></i></span> 这里查看。大体上如下：</p><table><thead><tr><th style="text-align:center">NodeJS</th><th>compilerOptions.target</th></tr></thead><tbody><tr><td style="text-align:center">6</td><td>es6 或 es2015</td></tr><tr><td style="text-align:center">8</td><td>es2016</td></tr><tr><td style="text-align:center">10</td><td>es2018</td></tr></tbody></table><h2 id="重载-Project"><a href="#重载-Project" class="headerlink" title="重载 Project"></a>重载 Project</h2><p>有些时候，VSCode IntelliSense 可能没起作用，比如新的函数没有出现在提示列表里。这个时候可以使用 <code>JavaScript: Reload Project</code> 命令，重新加载当前文件所在的 Project。如果还是不行，那就使用 <code>Reload Window</code> 命令——重启是能很多解决问题的。</p><p>接下来我们还要讲“非相对路径导入”、Click Through、ESLint 等各种特性或插件的使用。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具利器 Visual Studio Code 之 Settings（二）</title>
      <link href="/visual-studio-code-settings-2/"/>
      <url>/visual-studio-code-settings-2/</url>
      
        <content type="html"><![CDATA[<p>上一篇我们分享了 Visual Studio Code 全局配置（User Setting）里有关工作台与窗口的部分配置。请记住全局配置的三项原则，尤其是第三项<code>还要考虑那些会被临时打开的文件，尽量不要影响它们</code>。今天我们主要讲下编辑器相关的配置。</p><h2 id="单词分隔符支持中文符号"><a href="#单词分隔符支持中文符号" class="headerlink" title="单词分隔符支持中文符号"></a>单词分隔符支持中文符号</h2><p><code>&quot;editor.wordSeparators&quot;: &quot;`~!@#$%^&amp;*()-=+[{]}\\|;:&#39;\&quot;,.&lt;&gt;/！（）｛｝【】、；：’”，。《》？&quot;,</code><br>默认情况下，单词分隔符都是英文符号，比如空格、<code>,</code>、<code>.</code> 等。当执行单词相关的导航或操作时，这些分隔符就派上用场了。比如双击选中单词、使用 Alt + 左右箭头进行单词之间的跳转。纯英文的文字自然不会有问题，但是当我们在用 VSCode 写 Markdown 中文文档或写中文注释时，这些操作往往就不准确了。导致我们不得不使用鼠标或触摸板拖动选取，比较麻烦。<br><a id="more"></a> </p><p>就像下面这个中英文混合的文字，在默认配置下，如果双击“前端”这两个中文字符，则也会选中左侧的”Gateway“。Alt + 左右箭头进行单词之间跳转，也会包含这个英文。</p><p><img src="/images/vscode-setting2-word-1.gif" alt=""></p><p>而当我们加入中文符号作为单词分隔符后，再双击“前端”这两个中文字符，则不会选中左侧的”Gateway“，因为它被中文逗号分隔了。Alt + 左右箭头跳转也会以中文逗号为界了。</p><p><img src="/images/vscode-setting2-word-2.gif" alt=""></p><h2 id="禁用缩略图"><a href="#禁用缩略图" class="headerlink" title="禁用缩略图"></a>禁用缩略图</h2><p><code>&quot;editor.minimap.enabled&quot;: false,</code><br>编辑器的右侧默认会展示文本内容的缩略图。初看还是很惊艳的，而且在特定情况下还蛮有用。由于它是一个缩略，相当于把文本内容等比例缩小，而且是缩得很小。当文本内容大体是很规整（比如对齐、有特定形状）的时候，很容易从缩略图里看到那些破坏规整的行。但是大部分情况下，我们并不需要它。它占用了窗口一块区域，导致可编辑区域缩小。当我们要在桌面开启多个 VSCode，或者使用多列布局的时候，空间就很受限制了。</p><h2 id="修改-Tab-为两个空格"><a href="#修改-Tab-为两个空格" class="headerlink" title="修改 Tab 为两个空格"></a>修改 Tab 为两个空格</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"editor.tabSize"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"[python]"</span>: &#123;</span><br><span class="line">    <span class="attr">"editor.tabSize"</span>: <span class="number">4</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 Tab 替换为空格可以保证在不同软件、平台里显示时不会有什么差异，因为 Tab 的渲染差异就可能比较大。VSCode 中默认 Tab 等价于四个空格。但是四个空格还是比较占用缩进空间。一般一行代码不宜过长，控制在 80-100 字符为好。在稍微复杂的程序里，如果有三四层缩进，那么光空格就占用了 16 个字符。而两个空格的缩进看起来也还是很有层次结构的，所以就不要浪费空间了。当然了，有些语言对缩进有特殊的要求。尤其像 Python，社区统一规范四个空格作为缩进。所以这里我们要对 Python 文件恢复使用四个空格。</p><h2 id="自动折行"><a href="#自动折行" class="headerlink" title="自动折行"></a>自动折行</h2><p><code>&quot;editor.wordWrap&quot;: &quot;on&quot;,</code><br>尽管我们应该在写代码时尽量控制一行的字符数（比如不超过 80-100），但文档、注释还是可能会有超长的情况，还有就是看一些不太讲究的源码的时候。水平滚动在大部分情况下都不是一个很友好的交互形式：一则需要我们额外用鼠标按住横向滚动条来拖动滚动条（触摸板虽然方便些，但并不适用所有场景）；二来个别的长行在拖动到后面时往往会让界面大部分留白，失去大量有效信息，降低阅读效率。还好，VSCode 在显示折行后，并不会平添新的行号，这样一定程度也有助于我们判断是否是多行还是自动折行了。</p><h2 id="搜索时正则表达式支持正向、反向预查"><a href="#搜索时正则表达式支持正向、反向预查" class="headerlink" title="搜索时正则表达式支持正向、反向预查"></a>搜索时正则表达式支持正向、反向预查</h2><p><code>&quot;search.usePCRE2&quot;: true,</code><br>正则表达式中所谓的预查，就是只匹配，但不输出到结果中。如 <code>/(?&lt;=gate)way/.exec(&#39;gateway&#39;)</code> 将得到 <code>way</code>，而不包含 <code>gate</code>。虽然 ECMA2018 已经支持反向预查（lookbehind），但是 VSCode（1.31） 中暂时还没有。如果搜索时使用了反向预查，则会报错。而当开启上述配置后，我们就能进行反向预查搜索了。</p><p><img src="/images/vscode-setting2-regexp-lookbehind.png" alt=""></p><h2 id="强制文件的换行符为-n"><a href="#强制文件的换行符为-n" class="headerlink" title="强制文件的换行符为 \n"></a>强制文件的换行符为 \n</h2><p><code>&quot;files.eol&quot;: &quot;\n&quot;,</code><br>不同操作系统下的换行符都可能不一样，比如 Windows 下是 <code>\r\n</code>，而 Linux、macOS 是 <code>\n</code>。为了避免在不同环境下进行编辑时导致换行符的不一致，可以强制在 VSCode 中进行文件编辑时，使用统一的换行符。最好是用 <code>\n</code>，毕竟也节省了文件占用空间嘛。</p><p>还有其他一些全局配置，它们或跟插件相关，或跟语言、工程相关。在后续的具体场景中，会详细介绍它们的使用。接下来，我们将来看看如何利用 VSCode 最大化地方便 JavaScript 工程的编码。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macOS 下使用 CapsLock 键切换 ABC 与搜狗输入法</title>
      <link href="/macos-capslock-switch-input-source/"/>
      <url>/macos-capslock-switch-input-source/</url>
      
        <content type="html"><![CDATA[<p>在 macOS 下，默认的英文输入法 ABC 是不能删除的。它不能像 Windows 下那样，只要有一个搜狗输入法，然后在它内部切换中英文就够了。macOS 就不得不涉及如何在两个输入法之间做切换了。系统默认的切换快捷键是 Command + Space（空格）。但使用这个快捷键并不太好，因为很多编程用的 IDE 会用到这个快捷键，比如像 Visual Studio Code 里的智能提示（IntelliSense）。所以，我一般使用 CapsLock 来作为输入法切换键——因为它使用的频率低、离手近按键快。<br><a id="more"></a> </p><h2 id="macOS-Mojave-下使用系统自带支持"><a href="#macOS-Mojave-下使用系统自带支持" class="headerlink" title="macOS Mojave 下使用系统自带支持"></a>macOS Mojave 下使用系统自带支持</h2><p>可喜的是，在最新版的 macOS Mojave 下，已经默认支持了。</p><p><img src="/images/macos-capslock-mojave.png" alt=""></p><p>勾选后，只要按一下 CapsLock 就能在 ABC 和搜狗之间切换。而且长按就能激活大写——当然一般要输入大写，我感觉更方便地还是用左右 Shift 来输入，除非是要输入一长串大写字母（如全局变量）。</p><p>那么在 macOS High Sierra 和之前的版本里，该如何达到上述效果呢？有的同学可能有疑问，既然最新版已经实现了，为什么要讲旧版本呢？因为并不是所有人都愿意或立马升级到最新版。最新版在刚出来时，可能会有一些软件兼容性问题。比如这两天我就遇到了一个 VirtualBox 无法启动 macOS 虚拟机的问题。所以，对那些还留在旧版本的同学，我们还是有办法实现上述目标的，而且还是免费的，不用花钱、不用破解。关键就是 Karabiner Elements 这个软件。</p><h2 id="macOS-High-Sierra-以下使用-Karabiner-Elements-实现"><a href="#macOS-High-Sierra-以下使用-Karabiner-Elements-实现" class="headerlink" title="macOS High Sierra 以下使用 Karabiner Elements 实现"></a>macOS High Sierra 以下使用 Karabiner Elements 实现</h2><p>Karabiner Elements 是一款免费、开源的键盘定制化工具。可以通过 Homebrew 或前往官网（<span class="exturl" data-url="aHR0cHM6Ly9wcXJzLm9yZy9vc3gva2FyYWJpbmVyL++8ieS4i+i9veWuieijheWMhei/m+ihjOWuieijheOAguWug+WPr+S7peiHquWumuS5ieinhOWImeadpeS/ruaUueaMiemUruWumuS5ie+8jOWNgeWIhuaWueS+v+OAgui/memHjOaIkeS7rOeahOebruagh+aYr+aUueWGmQ==" title="https://pqrs.org/osx/karabiner/）下载安装包进行安装。它可以自定义规则来修改按键定义，十分方便。这里我们的目标是改写">https://pqrs.org/osx/karabiner/）下载安装包进行安装。它可以自定义规则来修改按键定义，十分方便。这里我们的目标是改写<i class="fa fa-external-link"></i></span> CapsLock 键——当单独按下 CapsLock 实体键，发送一个不占用任何按键的 F17；而当按下 fn + CapsLock 时，才是切换为大写状态。规则很简单，就是一个 JSON 配置：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"Using caps_lock to switch input source, see https://blog.kiliwalk.com/macos-capslock-switch-input-source/"</span>,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"kiliwalk(tianjianchn@qq.com)"</span>,</span><br><span class="line">  <span class="attr">"homepage"</span>: <span class="string">"https://blog.kiliwalk.com"</span>,</span><br><span class="line">  <span class="attr">"manual"</span>: <span class="string">"https://blog.kiliwalk.com/macos-capslock-switch-input-source/"</span>,</span><br><span class="line">  <span class="attr">"import_url"</span>: <span class="string">"karabiner://karabiner/assets/complex_modifications/import?url=https://blog.kiliwalk.com/images/caps_lock_switch_input_source.json"</span>,</span><br><span class="line">  <span class="attr">"rules"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"description"</span>: <span class="string">"Pressing caps_lock sends f17, pressing fn + caps_lock sends caps_lock"</span>,</span><br><span class="line">      <span class="attr">"manipulators"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"from"</span>: &#123;</span><br><span class="line">            <span class="attr">"key_code"</span>: <span class="string">"caps_lock"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"to"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">"key_code"</span>: <span class="string">"f17"</span></span><br><span class="line">            &#125;</span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"basic"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"from"</span>: &#123;</span><br><span class="line">            <span class="attr">"key_code"</span>: <span class="string">"caps_lock"</span>,</span><br><span class="line">            <span class="attr">"modifiers"</span>: &#123;</span><br><span class="line">              <span class="attr">"mandatory"</span>: [</span><br><span class="line">                <span class="string">"fn"</span></span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"to"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">"key_code"</span>: <span class="string">"caps_lock"</span></span><br><span class="line">            &#125;</span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"basic"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先要导入以上规则。有两种方法，一种是将以上内容保存为一个 JSON 文件（比如 caps_lock.json），然后复制到 <code>~/.config/karabiner/assets/complex_modifications</code> 目录下。还有就是直接使用 Safari 或 Chrome 浏览器，打开这个网址：<code>karabiner://karabiner/assets/complex_modifications/import?url=https://blog.kiliwalk.com/images/caps_lock_switch_input_source_v3.json</code>，它会询问你是否启动 Karabiner Elements，确定后，就可以了。</p><p>接下来我们要应用这个规则。进入 Karabiner Elements Preferences -&gt; Complex Modifications -&gt; Rules，点击左下角的 Add rule，找到 <code>Using caps_lock to switch input source...</code> 这条规则，点击 <code>Enable All</code> 即可。</p><p><img src="/images/macos-capslock-karabiner-import.png" alt=""></p><p>最后，我们还要去修改下系统里的切换输入法的快捷键（默认是 Command + Space）。前往 System Preferences -&gt; Keyboard -&gt; Shortcuts -&gt; Input Sources，选中 Select the previous input source（选择上一个输入法），点击右侧的按键区域，然后按下 CapsLock 实体键，此时上屏的是 F17。同时取消勾选 Select the next source in input menu（选择“输入法”菜单中的下一个输入法）。</p><p>这样，当我们按下 CapsLock 后，就能在搜狗和 ABC 之间进行切换了。如果需要大写，按下 fn + CapsLock 就可以。这里之所以不是用长按 CapsLock 进入大写，是 Karabiner Elements 的一些限制——配置复杂，且也不太稳定。</p><h2 id="搜狗输入法配置"><a href="#搜狗输入法配置" class="headerlink" title="搜狗输入法配置"></a>搜狗输入法配置</h2><p>除了系统层面快捷键的修改，搜狗输入法还要做一些调整。</p><ol><li>按键配置里，中英文状态切换改为“禁用快捷键”。因为我们不需要用搜狗输入法的英文输入模式了。</li><li>按键配置里，把当前输入态提示改为“无提示”。避免在按 CapsLock 切换时，还在桌面右上角提示大写状态。</li></ol><p><img src="/images/macos-capslock-sougou-config.png" alt=""></p><blockquote><p>拒绝生活的惯性，挖掘那些被我们习以为常的工具</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具利器 Visual Studio Code 之 Settings（一）</title>
      <link href="/visual-studio-code-settings-1/"/>
      <url>/visual-studio-code-settings-1/</url>
      
        <content type="html"><![CDATA[<p>Visual Studio Code 虽说是一款轻量的 IDE，但是它的可定制性却非常强大。早先继承了 Web 开发的传统，它使用 JSON 来管理配置。用户也是直接操作 JSON 格式的配置内容。严格来说 JSON 不支持注释，但它额外有了一种叫 JSON with Comments 的格式，支持 JavaScript 的行内、单行、跨行注释语法。这样对我这样的开发人员来说，感觉就很良好了。</p><p>Visual Studio Code 的配置分全局（User Settings）和工作区（Workspace Settings）。全局是对所有工程、所有工作区都生效的。工作区的配置会覆盖全局配置中相同条目的内容。今天我们就主要来看看全局配置。</p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><p>全局配置要有一定的规范，不能所有配置都需要、都能往里面加的。大概有三项原则：</p><ol><li>将那些通用的、最广泛用到的配置放到这里。</li><li>尽量少，精简为上，不重复默认配置。</li><li>还要考虑那些会被临时打开的文件，尽量不要影响它们。</li></ol><p>第一条、第二条我想大家都很容易理解，但第三条可能就不太注意了。由于开发工作中经常需要临时打开单个文件或目录，甚至还要去修改它们。这些临时打开的文件或目录并没有工作区配置，我们大概也不会想去为它们建一下工作区配置。这样，它们就只会应用全局配置了。所以在这里，我们有时候就要小心一点了。<br><a id="more"></a></p><h2 id="工作台与窗口"><a href="#工作台与窗口" class="headerlink" title="工作台与窗口"></a>工作台与窗口</h2><p>我们先来看看 Visual Studio Code 整个窗口与界面相关的定制。</p><h3 id="使用先前的-JSON-Editor-进行配置"><a href="#使用先前的-JSON-Editor-进行配置" class="headerlink" title="使用先前的 JSON Editor 进行配置"></a>使用先前的 JSON Editor 进行配置</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"workbench.settings.editor"</span>: <span class="string">"json"</span>,</span><br><span class="line">  <span class="attr">"workbench.settings.openDefaultSettings"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"workbench.settings.useSplitJSON"</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Visual Studio Code 在后续的版本中，默认使用 UI Editor 来进行配置。它就跟传统的界面配置方式一样，有一些输入框、下拉框等。虽然看起来更加“友好”了，不过作为一个开发人员，我还是更喜欢先前的 JSON Editor。JSON Editor 非常强大，不光支持上面说的注释，它还支持智能提示（IntelliSense）、自动补全。配置项的搜索也非常智能。</p><p><img src="/images/vscode-settings-intellisense.png" alt="">  </p><h3 id="显示文件相对路径"><a href="#显示文件相对路径" class="headerlink" title="显示文件相对路径"></a>显示文件相对路径</h3><p><code>&quot;window.title&quot;: &quot;${activeEditorMedium}${separator}${rootName}&quot;,</code><br>默认窗口标题只展示当前文件名称、工作区名称。如果一个工程内有多个相同文件名的文件（在不同目录下），就不好区分了。而使用这个配置，就可以在窗口标题上展示文件相对工作区根目录的“相对路径”。让人惊喜的是，如果这个文件不是当前工作区的，则会显示它的完整路径，而不是各种 <code>..\..</code> 组成的相对路径了。</p><h3 id="隐藏文件图标"><a href="#隐藏文件图标" class="headerlink" title="隐藏文件图标"></a>隐藏文件图标</h3><p><code>&quot;workbench.iconTheme&quot;: null,</code><br>默认情况下，在 Visual Studio Code 的资源管理器（Explorer）里，文件前会展示一个彩色图标，表示其类型。看起来确实挺炫的，不过它一定程度上影响了文件树的结构表达。使用这个配置，就能恢复清爽了。</p><h3 id="快速打开的文件不再是预览模式"><a href="#快速打开的文件不再是预览模式" class="headerlink" title="快速打开的文件不再是预览模式"></a>快速打开的文件不再是预览模式</h3><p><code>&quot;workbench.editor.enablePreviewFromQuickOpen&quot;: false,</code><br>所谓预览模式或预览编辑器（Preview Editor），就是可以被复用的标签页。当我们对多个文件进行单击打开时，只会使用同一个编辑器（Editor）标签窗口，这样就可以避免标签过多导致体验太差。双击标签页或编辑一下文件，就可以固定标签页，不再被复用了。而快速打开（Quick Open）是利用快捷键（Command + P）搜索并打开一个文件。它默认也是预览模式。但我一般的使用场景是，通过快速打开、搜索文件，主要是为了对这些文件进行处理（如编辑）或较长时间的查看（如对比等），而且一般都是多个文件要连续打开。这个跟对多个文件单击进行逐一浏览、检查就不太一样了。这样就把我们的操作分成两部分，使工作更加具有条理。通过这个配置就可以关闭快速打开的预览模式。</p><h3 id="自动定位当前文件在资源管理器中的位置"><a href="#自动定位当前文件在资源管理器中的位置" class="headerlink" title="自动定位当前文件在资源管理器中的位置"></a>自动定位当前文件在资源管理器中的位置</h3><p><code>&quot;explorer.autoReveal&quot;: false,</code><br>当我们打开一个文件，或激活一个文件标签窗口时，Visual Studio Code 会把这个文件在资源管理器中的位置显示出来并选中它。也就是说会自动展开树结构。看起来还不错。但是当你在多个文件标签窗口切换的时候，你会发现左侧的资源管理器的树可能都被展开了。这要是在目录较多、文件较多的工程里，就像有人把你好好打扫整理的房间又弄乱了，那种心情~~~。这个选项配合快速打开，就能保证左侧的文件树总是保持我们关心、期望的展开状态。</p><p>下一篇我们将会介绍下 Editor 相关的设置。请记住，我们的三项原则。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macOS PDF 转图片小探</title>
      <link href="/macos-pdf-to-images/"/>
      <url>/macos-pdf-to-images/</url>
      
        <content type="html"><![CDATA[<p>前几天有个朋友咨询我这个“修电脑的”：如果要把一个内部 PDF 文件发给别人，如何脱敏？当然别人也是他的朋友，只是给他参阅下，并不是要发到公网上传播。最简单的办法就是用 PDF 编辑软件把敏感部分都擦除掉啦。然而他用的是 macOS，这类编辑软件基本都是收费的，他又不想为此特意花那个钱（好像找我帮忙没有成本一样╮(╯_╰)╭）。在远在未来的一顿饭的压迫下，我只能去尝试下免费的方法了。<br><a id="more"></a></p><h2 id="Preview"><a href="#Preview" class="headerlink" title="Preview"></a>Preview</h2><p>macOS 的 Preview 是一个很强大的 App，可以查看图片，甚至做一些简单的图片编辑工作。令人惊喜的，它也可以查看 PDF 并且做一些涂鸦。<br>比如有这样一个 PDF 文件：<br><img src="/images/macos-pdf-original.png" alt=""><br>如果要把右侧的 Adobe 标遮掉，可以打开 <code>Show Mockup Toolbar</code>，使用 <code>Draw</code> 工具进行涂抹。<br><img src="/images/macos-pdf-mosaic.png" alt=""><br>但是这种方法有一个弊端，就是 PDF 被再次打开后，涂鸦可以被删除。</p><p>一个办法就是把 PDF 文件转为图片。从 Preview 的菜单 <code>File-&gt;Export</code>，选择格式为 JPEG 即可。但这个办法只能将 PDF 的第一页输出为图片，无法满足我们的要求。</p><h2 id="Automator"><a href="#Automator" class="headerlink" title="Automator"></a>Automator</h2><p>无奈，去网上搜索了一番。无意间发现可以利用 macOS 的 Automator 来达到批量转换 PDF 所有页到图片。经过对 Automator、Apple Script 一番研究，较为满意实现了以下目标：</p><ol><li>将 PDF 所有页都输出为图片</li><li>在 Finder 中集成右键菜单以便随时、快速地转换</li><li>这些图片可以输出在与 PDF 文件相同的文件夹下</li></ol><p><img src="/images/macos-pdf-automator.png" alt="">  </p><p>首先创建一个 Quick Action 类型的 Document，然后配置其输入为 Finder 中的 PDF 文件。这样只有 PDF 文件，会在右键的 Quick Action 菜单有此服务了。接下来每个步骤介绍如下：</p><ol><li>Set Value of Variable：将选中的文件作为对象赋值到变量 file 上</li><li>Run AppleScript：获取选中文件所在文件夹</li><li>Set Value of Variable：将该文件夹设置到变量 filefolder 上</li><li>Get Value of Variable：将变量 file 上的文件作为下个步骤的输入。如果没有这一步，则 filefolder 会作为下个步骤的输入了。</li><li>Render PDF Pages as Images：将 PDF 文件的每一页输出为图片。这一步就是我们要的批量处理。</li><li>Move Finder Items：将上述图片文件移动到 filefolder 变量所指向的文件夹中，也就是跟源文件相同的目录中。因为上一步默认会把图片存在 /private/var/folders 的某个目录下。</li></ol><p>然后将此 Document 保存，名称可以取为 <code>PDF to Images</code>。我们可以看看具体使用办法： </p><p><img src="/images/macos-pdf-pdf-to-images.gif" alt=""></p><p>但是这个办法还是有一个问题没法解决——有些 PDF 文件设置了导出密码。必须把密码清除了，才能使用 Automator 来处理。如果不知道密码，那就行不通了。</p><h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><p>那还有其他什么办法吗？截图！当然，不是说手动一张一张去截屏，而是有一个 App 就叫<span class="exturl" data-url="aHR0cHM6Ly9qaWV0dS5xcS5jb20v" title="https://jietu.qq.com/">“截图（Jietu）”<i class="fa fa-external-link"></i></span>。它支持滚动截图，而且是免费的。但是这个滚动截图功能在某些情况会漏掉或重复截屏。也可能因为这样，所以最新的 2.2.2 版本也没有了这个功能。不过还好我有 2.2.1 版本的。用 Preview 打开 PDF 文件后，利用滚动截屏功能顺利地截取到了所有页面的一个长图。没有遗漏或重复，当然也有可能是 PDF 文件页数比较少。好几十页乃至上百页的还没有测试过。</p><p>到这里，总算可以交差了。然而事情并没有结束。当我尝试对十几页的长图片用 Preview 预览，放大时竟然无法正常显示内容（可能由于图片太大的缘故）。于是我又脑洞地把这张长图转为了 PDF。这样的 PDF 只有一页，这一页的中间就是一个细长条的图片，必须放大后才能看清。嗯，把这样的 PDF 发出去，自然也增加了阅读成本，这大概也可以算是脱敏的一部分吧:) </p><p>希望朋友不要忘记这一顿饭。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS Docker 打包优化</title>
      <link href="/nodejs-docker-optimize/"/>
      <url>/nodejs-docker-optimize/</url>
      
        <content type="html"><![CDATA[<p>最近 NodeJS 后端工程的 Docker 打包优化工作总算告一段落了。其实去年 12 月份就开始试点改造，期间遇到了很难复现的间歇性 <code>socket hang up</code> 问题，不得不延后。上周终于抽出时间全力排查了下，发现是升级 NodeJS 到 6.15.0 后，其有一个 HTTP Keep-alive 连接超时的 Bug。不得不感慨：这小版本升级也要格外小心啊。</p><p>回到正题。在确认没有其他附带问题后，在试点的基础上，又增加了一些新的目标。总的目标大概如下：</p><ul><li>支持优雅停机，要求 Node 进程能够接收到 SIGTERM 软终止信号</li><li>提升打包速度，充分利用 Docker Layer 缓存机制，降低 yarn install、node_modules 拷贝等高 IO 动作的运行频率</li><li>保证源代码安全，不要将源代码打包到镜像里</li><li>尽可能降低最终镜像大小，不要包含不必要的文件（如 node_modules 中的 devDependencies）</li></ul><p>下面从各个目标一一介绍下我们的优化实践之路。<br><a id="more"></a><br><img src="/images/nodejs-docker.jpg" alt=""></p><h2 id="基础镜像设置"><a href="#基础镜像设置" class="headerlink" title="基础镜像设置"></a>基础镜像设置</h2><p>由于之前的基础镜像使用的是 <code>FROM node:6</code>，只有 major version，没有指定 minor version、patch version。当该基础镜像 minor 或 patch 版本更新后，如果本地的镜像缓存也被清除了，那么打包就会使用新版本的基础镜像。这也是上面不经意升级到 node 6.15.0 的原因。所以这里我们限定了基础镜像的全版本：<code>FROM node:6.16.0</code>。</p><p>我们的产品主要在国内使用，运维人员也都是在国内。为了更方便查看日志中的时间、方便程序中的日期计算，把时区调整为北京时区（即东八区）：<code>RUN rm /etc/localtime &amp;&amp; echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone &amp;&amp; dpkg-reconfigure -f noninteractive tzdata</code>。注意，Debian Stretch 版本后需要 <code>rm /etc/localtime</code>，否则时区修改可能无法生效（被替换回原值）。</p><p>最后设置镜像的工作目录：<code>WORKDIR /app</code>。这样，我们新的基础镜像就完成了。</p><h2 id="支持优雅停机"><a href="#支持优雅停机" class="headerlink" title="支持优雅停机"></a>支持优雅停机</h2><p>优雅停机（Gracefully Shutdown），就是当应用（进程）要被关闭时，首先会被发送一个软终止信号。应用在收到这个信号后，执行清理工作，然后自行退出。如果在指定的时间内没有自行退出，则会被强制关闭——这自然就不优雅了。这个软终止信号一般就是指 SIGTERM。NodeJS 进程默认会对 SIGTERM 信号进行响应，执行进程退出。但是默认的监听程序并不会执行清理工作。我们需要显式监听该信号，并在清理完毕后执行 <code>process.exit(0)</code> 以退出进程。</p><p>然而，在 Docker 容器里实现优雅停机会有一些新的问题需要面对。当使用 <code>docker stop</code> 停止一个容器时，docker 会首先发送一个 SIGTERM 信号给容器内的 PID=1 进程，也就是常说的 init 进程。如果 PID=1 进程没有在规定时间（一般 10 秒）内退出，则 docker 会发送 SIGKILL 信号强制退出容器内的所有进程。PID=1 进程比较特殊，在 linux 下，它会忽略所有默认的信号监听程序，也就是说收到 SIGTERM 默认不会退出。<!-- 参考：https://hackernoon.com/my-process-became-pid-1-and-now-signals-behave-strangely-b05c52cc551c -->所以，我们的 PID=1 进程要求能显式监听 SIGTERM 并执行后续动作。</p><p>然而，当我们使用 shell form 的 ENTRYPOINT 或 CMD 指令时——如 <code>CMD npm run start</code>，Docker 容器会默认启用一个 Shell 来运行后面的指令。此时 PID=1 进程是 <code>/bin/sh</code>，完整的运行命令是 <code>/bin/sh -c &#39;npm run start&#39;</code>。当 sh 收到 SIGTERM 信号时，它自身并不会退出。因为 sh 并没有显式监听 SIGTERM，默认的信号处理器被忽略了。自然 sh 内部也不会把信号转发给子进程。<!-- 参考：https://github.com/nodejs/node/issues/2098 -->最后只会超时，继而被 SIGKILL 强制关闭。</p><p>Docker 推荐我们用 exec form 的 ENTRYPOINT 或 CMD 指令，如 <code>CMD [&quot;npm&quot;, &quot;run&quot;, &quot;start&quot;]</code>。这样 PID=1 进程就是 npm 了，不再有 sh 进程了。但继续用 npm scripts 会不会还有问题？这就依赖 Host 环境了。我们来看一下 npm scripts 的运行原理。以 <code>npm run start</code> 为例，在运行时，首先会起一个 npm 进程。npm 进程会 <code>spawn()</code> 一个 <code>/bin/sh</code> 进程（<code>/bin/sh -c</code>），执行 <code>start</code> script 的内容（通常就是 <code>node xxx.js</code>）。这样就形成了三个进程构成的进程树，分别是 npm、sh、node。当 npm 进程收到 SIGTERM 信号时，它内部已经监听 SIGTERM，其逻辑就是转发给子进程，也就是 sh 进程。sh 进程收到信号后退出，接着 npm 也退出了。但是，剩下的 node 进程并没有收到信号，它被忽略了，继而被 Docker 直接 SIGKILL。看起来完全不行嘛，那为什么说依赖 Host 环境呢？因为中间这个 sh 进程在 bash 里（<code>/bin/sh</code> 指向 bash），是有可能不存在的。是不是很神奇？当使用 <code>-c</code> 运行命令时，bash 会判断是否需要 <code>fork()</code> 当前进程以产生一个新的进程来执行该命令。<!-- 参考：https://stackoverflow.com/questions/44576773/bash-swallowing-sub-shell-children-process-when-executing-a-single-command -->当 <code>-c</code> 命令不包含复杂的结构，如多个命令连接（<code>&amp;&amp;</code>、<code>||</code>）、重定向（<code>&gt;</code>）等情况时，bash 不会 <code>fork()</code> 出新的子进程，而是直接使用 <code>exec()</code> 替换当前进程。而 <code>node:6</code> Docker 镜像所用的 Debian Stretch 操作系统，<code>/bin/sh</code> 默认指向的是 dash，而不是 bash。所以在这里，我们最好也不要用 npm scripts。</p><p>那我们就只剩一个选项了：直接将 node 作为 PID=1 的进程，如 <code>CMD [&quot;node&quot;, &quot;dist/server.js&quot;]</code>。虽然说 PID=1 的进程还要处理僵尸进程（Zombie Process），但我们这里基本上不会有，也就可以不考虑了。<!-- 参考：https://engineeringblog.yelp.com/2016/01/dumb-init-an-init-for-docker.html --></p><h2 id="yarn-install-优化"><a href="#yarn-install-优化" class="headerlink" title="yarn install 优化"></a>yarn install 优化</h2><p>这方面最基础的一个优化就是利用 Docker Layer 缓存特性，降低 yarn install 的发生次数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 package.json、yarn.lock 没有变化的情况下，后面的 yarn install 会直接复用上次打包的缓存结果</span></span><br><span class="line">COPY package.json yarn.lock</span><br><span class="line">RUN yarn install --frozen-lockfile</span><br></pre></td></tr></table></figure></p><p>要注意的一个问题是，yarn 会在其他位置建立依赖缓存（cache）。可以用 <code>yarn cache clean</code> 来移除缓存。不过我们这里并没有用，因为后面的改造方式让我们不需要它了。</p><p>我们的工程依赖里有私有 Git 仓库，如 <code>&quot;js-util&quot;: &quot;git+ssh://git@gitlab.xxx.com:yyy/library/js-util.git#v2&quot;</code>。我们原先的 CI 过程，是在宿主机上先安装依赖，然后把整个 node_modules 拷贝到 Docker Server 端中进行打包。宿主机有 SSH Key（一般就是 Gitlab Deploy Key，注意不要加密码，否则无法在 non-interactive shell 下使用），下载私有 Git 仓库不会有权限问题，但是就无法利用上述的缓存优化了。鱼和熊掌不可兼得，那就选中间。如果我们把 SSH Key 也打包到镜像里呢？那就太不安全了。那把它从镜像里又删除呢？可惜还是有安全隐患——Docker 的 Union FS 机制会导致这些文件还存在于原来的 Layer 里。</p><p>解决这个问题没有特别完美的方法。可以尝试提供一个内网的 SSH Key 在线下载地址，使用一个 RUN 指令完成 wget、ssh-add、yarn install、rm 等一系列操作，保证没有任何一个 Layer 会留存 SSH Key。而我们这里采用的是 Multi Stage Build——多阶段打包机制。在阶段一，复制 SSH Key，获取 Gitlab 服务器的公钥，并执行 yarn install。在阶段二，把阶段一打包出来的内容复制过来，注意这里不要复制 SSH Key。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建时需要执行的指令</span></span><br><span class="line">FROM node:6.16.0 as build</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY .ssh /root/.ssh/</span><br><span class="line">RUN chmod 600 /root/.ssh/id_rsa &amp;&amp; ssh-keyscan gitlab.xxx.com &gt; /root/.ssh/known_hosts</span><br><span class="line">COPY package.json yarn.lock ./</span><br><span class="line">RUN yarn install --frozen-lockfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行时需要执行的指令</span></span><br><span class="line">FROM node:6.16.0 as runtime</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY --from=build /app/node_modules /app/node_modules/</span><br></pre></td></tr></table></figure></p><p>这样，阶段二打包出来的最终镜像，就没有 SSH Key 了。至于阶段一的 .ssh 目录，可以在调用 <code>docker build</code> 之前，从 <code>$HOME/.ssh/id_rsa</code> 上复制到当前目录，可千万别上传到 Git 仓库哦。</p><h2 id="打包速度优化"><a href="#打包速度优化" class="headerlink" title="打包速度优化"></a>打包速度优化</h2><p>在充分利用 Docker Layer 缓存机制的基础上，我们需要把那些不容易产生变更的指令放到上面、把不容易产生变更的部分剥离出来。像 WORKDIR、CMD、ENV、还有一些环境配置指令，都可以放到前面。把文件复制过程中，不容易产生变更的文件单独抽离出来，形成一个新的 COPY 指令，尽量避免 <code>COPY . /p/a/t/h/</code> 这样的复制方式。说到 COPY，还要注意其跟 Linux <code>cp</code> 命令有一些不一样的地方。当复制一个目录时，COPY 是将这个目录下的所有文件复制到目标文件夹下，而不是把这个目录自身复制到目标文件夹中。</p><h2 id="源代码安全"><a href="#源代码安全" class="headerlink" title="源代码安全"></a>源代码安全</h2><p>在最终的镜像里，最好不要包括源代码，而只有 Transpile、Uglify 甚至是 Minify 后的代码。我们使用 <code>npm run build</code> 来做这些转换工作，它会把 src 源代码目录，转换到 dist 目录。使用上面的多阶段打包，只要在第二阶段 COPY dist 目录即可。</p><h2 id="镜像大小优化"><a href="#镜像大小优化" class="headerlink" title="镜像大小优化"></a>镜像大小优化</h2><p>最终打包出来的镜像大小，除了基础镜像 <code>node:6.16.0</code> 占用大部分空间外，剩下的主要就是 <code>node_modules</code> 目录了——大概有 200-300MB。我们可以考虑把 <code>devDependencies</code> 从 node_modules 中删除来减少大小。再增加一条指令：<code>RUN yarn install --production</code> 即可。然而我们并没有这样做，主要有这两个原因：</p><ol><li>我们在注册了 <code>postinstall</code> npm scripts，它依赖一些 <code>devDpendencies</code>。</li><li>由于还有 <code>npm run build</code>，它所依赖的 babel 都是 <code>devDpendencies</code>。由于它必须在 COPY 源代码之后运行，意味着只要源代码有变化，<code>npm run build</code> 就会被执行。那还在它后面的 <code>yarn install --production</code> 自然也会被再次执行，可能就会影响打包效率了。</li></ol><h2 id="上下文目录优化"><a href="#上下文目录优化" class="headerlink" title="上下文目录优化"></a>上下文目录优化</h2><p><code>docker build -t xxx .</code>，最后的那个 <code>.</code> 就表示上下文目录位置（<code>.</code> 就是当前目录）。docker build 是在 go 语言写的一个本地服务端上运行。所以一开始需要把上下文目录打包发送到服务端，然后在服务端内解压，再运行各个指令，生成最终的镜像。这样我们的上下文目录就不能太大，不然 IO 吃不消。我们可以用 .dockerignore 文件来限制上下文目录只包含哪些文件。为了得到一个比较通用的 .dockerignore 文件，我们主要使用排除法规则。排除那些容器运行时不需要的文件；排除那些不会在多阶段打包过程中使用的中间文件，如 node_modules、dist。示例 .dockerignore 文件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">!package.json</span><br><span class="line">!yarn.lock</span><br><span class="line">!src</span><br><span class="line">!bin</span><br><span class="line">!test</span><br><span class="line">!gulpfile.js</span><br><span class="line">!.babel*</span><br><span class="line">!.eslint*</span><br><span class="line">!.nycrc</span><br><span class="line">!.ssh</span><br></pre></td></tr></table></figure></p><h2 id="最终的-Dockerfile"><a href="#最终的-Dockerfile" class="headerlink" title="最终的 Dockerfile"></a>最终的 Dockerfile</h2><p>把上面各个改造结合在一起，我们的 Dockerfile 就出炉啦！还有一些小细节，期待你自己的发现哦。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############################################</span></span><br><span class="line"><span class="comment">#                 构建阶段</span></span><br><span class="line"><span class="comment">############################################</span></span><br><span class="line">FROM node:6.16.0 as build</span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行 docker build 前需要把 SSH Keys 复制到当前目录下的 .ssh 中，并在 build 完后删除</span></span><br><span class="line">COPY .ssh /root/.ssh/</span><br><span class="line">RUN chmod 600 /root/.ssh/id_rsa &amp;&amp; ssh-keyscan gitlab.xxx.com &gt; /root/.ssh/known_hosts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 package.json、yarn.lock 没有变化的情况下，yarn install 会复用上次的缓存结果</span></span><br><span class="line">COPY package.json yarn.lock ./</span><br><span class="line">RUN yarn install --frozen-lockfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意使用 .dockerignore 来屏蔽掉不必要的文件</span></span><br><span class="line">COPY . ./</span><br><span class="line"></span><br><span class="line">RUN npm run lint &amp;&amp; npm run build &amp;&amp; npm run <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">############################################</span></span><br><span class="line"><span class="comment">#        运行时，也即最终的 Image 内容</span></span><br><span class="line"><span class="comment">############################################</span></span><br><span class="line">FROM node:6.16.0 as runtime</span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一行，设置时区为北京时区（东八区）</span></span><br><span class="line"><span class="comment"># 第二行，解决 npm log 日志中掺杂命令行控制符导致日志解析、匹配困难的问题</span></span><br><span class="line">RUN rm /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="string">"Asia/Shanghai"</span> &gt; /etc/timezone &amp;&amp; dpkg-reconfigure -f noninteractive tzdata \</span><br><span class="line">  &amp;&amp; npm config <span class="built_in">set</span> color <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">ENV NODE_ENV=<span class="string">"production"</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 不要使用 npm，也不要用 shell form，避免 node 进程无法收到 SIGTERM 信号。</span></span><br><span class="line">ENTRYPOINT [<span class="string">"node"</span>]</span><br><span class="line">CMD [<span class="string">"dist/server.js"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行时需要的文件</span></span><br><span class="line">COPY --from=build /app/package.json /app/yarn.lock ./</span><br><span class="line">COPY --from=build /app/node_modules /app/node_modules/</span><br><span class="line">COPY --from=build /app/dist /app/dist/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Nodejs </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微前端实践</title>
      <link href="/micro-frontend-practice/"/>
      <url>/micro-frontend-practice/</url>
      
        <content type="html"><![CDATA[<p>在 toB 的前端开发工作中，我们往往就会遇到如下困境：</p><ol><li>工程越来越大，打包越来越慢</li><li>团队人员多，产品功能复杂，代码冲突频繁、影响面大</li><li>内心想做 SaaS 产品，但客户总是要做定制化</li></ol><p>不同的团队可能有不同的方法去解决这些问题。在前端开发日新月异、前端工程化蓬勃发展的今天，我想给大家介绍下另一种尝试——微前端。<br><a id="more"></a></p><h2 id="微前端是什么"><a href="#微前端是什么" class="headerlink" title="微前端是什么"></a>微前端是什么</h2><p>那什么是微前端？微前端主要是借鉴后端微服务的概念。简单地说，就是将一个巨无霸（Monolith）的前端工程拆分成一个一个的小工程。别小看这些小工程，它们也是“麻雀虽小，五脏俱全”，完全具备独立的开发、运行能力。整个系统就将由这些小工程协同合作，实现所有页面的展示与交互。</p><p><img src="/images/micro-service-vs-micro-frontend.png" alt=""><br>可以跟微服务这么对比着去理解：</p><table><thead><tr><th style="text-align:center">微服务</th><th style="text-align:center">微前端</th></tr></thead><tbody><tr><td style="text-align:center">一个微服务就是由一组接口构成，接口地址一般是 URL。当微服务收到一个接口的请求时，会进行路由找到相应的逻辑，输出响应内容。</td><td style="text-align:center">一个微前端则是由一组页面构成，页面地址也是 URL。当微前端收到一个页面 URL 的请求时，会进行路由找到相应的组件，渲染页面内容。</td></tr><tr><td style="text-align:center">后端微服务会有一个网关，作为单一入口接收所有的客户端接口请求，根据接口 URL 与服务的匹配关系，路由到对应的服务。</td><td style="text-align:center">微前端则会有一个加载器，作为单一入口接收所有页面 URL 的访问，根据页面 URL 与微前端的匹配关系，选择加载对应的微前端，由该微前端进行进行路由响应 URL。</td></tr></tbody></table><p>这里要注意跟 iframe 实现页面嵌入机制的区别。微前端没有用到 iframe，它很纯粹地利用 JavaScript、MVVM 等技术来实现页面加载。后面我们将介绍相关的技术实现。</p><h2 id="为什么要用微前端"><a href="#为什么要用微前端" class="headerlink" title="为什么要用微前端"></a>为什么要用微前端</h2><p>在介绍具体的改造方式之前，我想跟大家先说明下我们当时面临的问题，以及改造后的对比，以便大家以此为对照，评判或决定使用。主要包括打包速度、页面加载速度、多人多地协作、SaaS 产品定制化、产品拆分这几个角度。</p><p>首先是打包速度。在 6 个月前，我们的 B 端工程那会儿还是一个 Monolith。当时已经有 20 多个依赖、60 多个公共组件、200 多个页面，对接 700 多个接口。我们使用了 Webpack 2，并启用 DLL Plugin、HappyPack 4。在我的个人主机上使用 4 线程编译，大概要 5 分钟。而如果不拆分，算下来现在我们已经有近 400 个页面，对接1000 多个接口。<br>这个时间意味着什么？它不仅会耽误我们开发人员的时间，还会影响整个团队的效率。上线时，在 Docker、CI 等环境下，耗时还会被延长。如果部署后出几个 Bug，要线上立即修复，那就不知道要熬到几点了。<br>在使用微前端改造后，目前我们已经有 26 个微前端工程，平均打包时间在 30-45 秒之间（注意，这里还没有应用 DLL + HappyPack）。</p><p>页面加载速度其实影响到并不是很大，因为经过 CDN、gzip 后，资源的大小还能接受。这里只是给大家看一些直观的数据变化。6 个月前，打包生成的 app.js 有 5MB（gzip 后 1MB），vendor.js 有 2MB（gzip 后 700KB），app.css 有 1.5MB（gzip 后 250KB）。这样首屏大概要传输 2MB 的内容。拆分后，目前首屏只需要传输 800KB 左右。</p><p>在协作上，我们在全国有三个地方的前端团队，这么多人在同一个工程里开发，遭遇代码冲突的概率会很频繁，而且冲突的影响面比较大。如果代码中出现问题，导致 CI 失败，所有其他人的代码提交与更新也都会被阻塞。使用微前端后，这样的风险就平摊到各个工程上去了。</p><p>再者就是定制化了。我们做的额是一款 toB 的产品，做成 SaaS 标准版产品大概是所有从业者的愿望。但整体市场环境与产品功能所限，经常要面临一些客户要求做本地化与定制化的要求。本地化就会有代码安全方面的考量，最好是不给客户源代码，最差则是只给客户购买功能的源代码。而定制化从易到难则可以分为独立新模块、改造现有模块、替换现有模块。<br>通过微前端技术，我们可以很容易达到本地化代码安全的下限——只给客户他所购买的模块的前端源码。定制化里最简单的独立新模块也变得简单：交付团队增加一个新的微前端工程即可，不需要揉进现有研发工程中，不占用研发团队资源。而定制化中的改造现有模块也可以比较好地实现：比如说某个标准版的页面中需要增加一个面板，则可以通过一个新的微前端工程，同样响应该页面的 URL（当然要控制好顺序），在页面的恰当位置插入一个新的 DOM 节点即可。</p><p>最后就是产品拆分方面的考量了。我们的产品比较大，有几块功能比较独立、有特色。如果说将来需要独立成一个子产品，有微前端拆分作为铺垫，腾挪组合也会变得更加容易些。</p><h2 id="其他目标"><a href="#其他目标" class="headerlink" title="其他目标"></a>其他目标</h2><p>有了以上的一些原因与诉求，在决定进行微前端改造前，还需要设定一些额外的小目标：</p><ul><li>不能对现有的前端开发方式带来太大变化，至少要有平滑过渡的机制。</li><li>每个为前端工程都要求可以独立运行，至少在本地开发时要能做到。</li><li>微前端在加载时，要实现预加载，并可以自由调整预加载顺序，甚至是根据用户的偏好来实现智能化、个性化的加载顺序。</li></ul><h2 id="如何改造现有工程"><a href="#如何改造现有工程" class="headerlink" title="如何改造现有工程"></a>如何改造现有工程</h2><p>“Talk is cheap，show me the code“。下面就让我们一起来看看具体的改造吧！我们的微前端工程可以划分为 portal 工程、业务工程、common 工程这几类。</p><h3 id="portal-工程"><a href="#portal-工程" class="headerlink" title="portal 工程"></a>portal 工程</h3><p>portal，顾名思义，就是入口。这也就是上面所说的微前端加载器。当用户打开浏览器，首次进入我们的页面时，不管是什么 URL，首先加载的就是 portal。portal 里会配置所有业务工程的地址、匹配哪些 URL、需要加载哪些资源。如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务工程的名称</span></span><br><span class="line">customer: &#123;</span><br><span class="line">    <span class="comment">// URL 匹配模式</span></span><br><span class="line">    matchUrlHash: [<span class="string">'^/customer'</span>],</span><br><span class="line">    <span class="comment">// 微前端地址</span></span><br><span class="line">    target: <span class="string">'http://localhost:8101/mfe-customer/index.html'</span>,</span><br><span class="line">    <span class="comment">// 资源匹配模式</span></span><br><span class="line">    resourcePatterns: [<span class="string">'/app.*.css$'</span>, <span class="string">'/vendor.*.css$'</span>, <span class="string">'/manifest.*.js$'</span>, <span class="string">'/vendor.*.js$'</span>, <span class="string">'/app.*.js$'</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>portal 会定时、异步、并发地下载业务工程的资源，并将它们进行注册，此时并不会加载这些业务工程。这里之所以要业务工程的地址（target）、资源（resourcePatterns），是为了加载时确定地知道其所包含的 app.js、vendor.js、app.css 等资源的路径。因为业务工程每次有变更，app.js 等资源路径上都会带有新的文件内容哈希值（Hash），导致路径不可预测。而它的 index.html 的路径是固定的。我们读取该 HTML，解析其内容，通过正则就能匹配到 app.js 等资源的路径。</p><p>portal 在运行时，会监听 URL 变化。目前我们只支持 URL Hash（如 #/customer）。当 Hash 发生变更时，匹配到业务工程，然后执行卸载、加载的工作。这个机制主要是利用 <code>single-spa</code> 来实现，但原理就是这么简单。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; registerApplication &#125; <span class="keyword">from</span> <span class="string">'single-spa'</span>;</span><br><span class="line">registerApplication(<span class="string">'customer'</span>, </span><br><span class="line">    <span class="comment">// 下载微前端工程，获取三个函数钩子：bootstrap、mount、unmount</span></span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> html = fetch(mfeConfig.target);</span><br><span class="line">        <span class="keyword">const</span> &#123;cssUrls, jsUrls&#125; = match(html, mfeConfig.resourcePatterns);</span><br><span class="line">        loadCss(cssUrls);</span><br><span class="line">        loadJs(jsUrls);</span><br><span class="line">        <span class="keyword">return</span> windows[<span class="string">'mfe:customer'</span>];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 对当前浏览器 URL Hash 进行匹配，如果匹配（返回 true），则加载该微前端（调用 mount）；否则卸载（调用 unmount）</span></span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> match(<span class="built_in">window</span>.location.hash, mfeConfig.matchUrlHash);</span><br><span class="line">    &#125;,</span><br><span class="line">    mfeConfig.customProps</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h3 id="业务工程"><a href="#业务工程" class="headerlink" title="业务工程"></a>业务工程</h3><p>业务工程就是普通的微前端工程，一般一个模块一个工程。业务工程要扮演两个角色，一个是可独立运行的前端工程，一个是受 portal 控制的运行时。前者主要用于我们本地开发，后者则是线上集成时使用。在独立运行时，它跟原来的前端工程没有什么区别。以 Vue 工程为例，照样使用 <code>new Vue({el: &#39;#app&#39;})</code> 来启动、渲染页面。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    i18n,</span><br><span class="line">    router,</span><br><span class="line">    store,</span><br><span class="line">    template: <span class="string">'&lt;App/&gt;'</span>,</span><br><span class="line">    components: &#123; App &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>而当受控运行时，则是利用 UMD 方式输出几个钩子函数，包括初始化、加载、卸载。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">window</span>.IS_IN_MFE)&#123; <span class="comment">// 独立运行时</span></span><br><span class="line">    <span class="keyword">new</span> Vue(&#123;...&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 受控运行时</span></span><br><span class="line">    <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">        bootstrap()&#123; <span class="comment">// 注册时执行</span></span><br><span class="line">        &#125;,</span><br><span class="line">        mount(customProps)&#123; <span class="comment">// 加载时执行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Vue(&#123;...&#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        unmount()&#123; <span class="comment">// 卸载时执行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            instance.$destroy()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>线上环境的 Webpack 配置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    libraryTarget: <span class="string">"umd"</span>,</span><br><span class="line">    library: <span class="string">'mfe:customer'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而区分是否受控，则可以通过判断一个全局变量来实现。如 <code>window.IS_IN_MFE</code>，portal 工程在运行时会将其设置为 <code>true</code>。</p><p>为了支持本地多个工程同时开发，我们需要为每个微前端工程指定一个确定的、独占的端口号。比如从 8100 开始，逐一递增。同时，为了支持线上部署，我们还需要给每个微前端工程指定一个确定的、独占的基础路径（前缀）。这样相同域名下可以用不同路径进行独立访问。路径统一以 <code>/mfe-</code> 开头，如 <code>/mfe-customer</code>。这也就是上面 portal 里业务工程的配置示例里所展现的那样。</p><h3 id="特殊业务工程：mfe-navs"><a href="#特殊业务工程：mfe-navs" class="headerlink" title="特殊业务工程：mfe-navs"></a>特殊业务工程：mfe-navs</h3><p>我们产品的页面结构分为顶部栏、侧边栏、中间内容区三大块。顶部栏和侧边栏在页面跳转过程中，基本上保持不变。所以我们也将它们剥离出来作为一个独立的微前端业务工程，叫做 <code>mfe-navs</code>。它会匹配所有的 URL，也就是说访问任意 URL 时，都会加载它，而且还要保证先加载它。当它加载完毕后，会在页面内提供一个中间内容区的锚点 DOM（<code>#app</code>：），供其他业务工程加载时挂载。</p><h3 id="Common-工程"><a href="#Common-工程" class="headerlink" title="Common 工程"></a>Common 工程</h3><p>上面可以看到，每一个业务工程都是一个独立的前端工程，所以里面会有一些相同的依赖，如 Vue、moment、lodash 等。如果将这些内容都打包到各自的 vendor.js 里，则势必会导致代码冗余太多，浏览器运行内存压力增大。我们把这些公共依赖、公共组件、CSS、Fonts 等都放到一个工程里，由该工程进行打包，将依赖、组件 export，并以 UMD 的方式注入到全局。</p><p>main.js：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>; <span class="comment">// 公共依赖</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span>;</span><br><span class="line"><span class="keyword">import</span> VueI18n <span class="keyword">from</span> <span class="string">'vue-i18n'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'@/css/icon-font/iconfont.css'</span>;</span><br><span class="line"><span class="keyword">import</span> ContentSelector <span class="keyword">from</span> <span class="string">'@/components/ContentSelector'</span>; <span class="comment">// 公共组件</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueI18n); <span class="comment">// 大家都要这么做，我们就代劳吧！</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="string">'vue'</span>: Vue,</span><br><span class="line">    <span class="string">'vue-router'</span>: VueRouter,</span><br><span class="line">    <span class="string">'content-selector'</span>: ContentSelector,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>Webpack 配置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    libraryTarget: <span class="string">"umd"</span>,</span><br><span class="line">    library: <span class="string">'mfe:common'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>业务工程则通过 Webpack 外部依赖（external）的方式引入到工程中。这样业务工程打包时就不会包含这些公共代码了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> externalModules = [<span class="string">'vue'</span>, <span class="string">'vue-router'</span>, <span class="string">'content-selector'</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; <span class="comment">// webpack 配置项</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    externals: <span class="function">(<span class="params">context, request, callback</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(externalModules.includes(request))&#123;</span><br><span class="line">            callback(<span class="literal">null</span>, <span class="string">'root window["mfe:common"]["'</span>+request+<span class="string">'"]'</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            callback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上就是我们微前端改造与实践方面的一些经验。前路漫漫，这里面还存在很多待完善的地方，如 History 模式支持、i18n 更好地集成、各个业务工程的加载顺序优化及个性化等。除了这些纯粹技术上的探索，在拥有微前端、微服务这些架构的基础上，团队也可以考虑进行垂直拆分：一个小组独立负责一块业务，它有自己的微前端工程和微服务工程。从技术管理到人员管理，将它们糅合在一起统一考虑，这也是我们软件工程的探索方向。期待这些能够对大家带来一些思考和帮助！</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Coding </tag>
            
            <tag> Frontend </tag>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具利器之 Visual Studio Code（一）</title>
      <link href="/tool-sharp-of-visual-studio-code-1/"/>
      <url>/tool-sharp-of-visual-studio-code-1/</url>
      
        <content type="html"><![CDATA[<p>前面的文章<a href="https://blog.kiliwalk.com/2018/11/23/the-developer-i-want/">《我看开发》</a>中提到要从工具、编码、设计上去提升我们的开发水平。今天我们就先从 Visual Studio Code 这款编程开发软件来看看工具方面的实践。</p><p>Visual Studio Code 是微软推出的一款开源、轻量、跨平台、主要面向 Web 开发的 IDE（集成开发环境）。它是基于 Chrome + NodeJS 这种 Web Hybrid 方案实现的，有别于传统的那些基于本地 Native 开发的 IDE，如 Visual Studio、Eclipse、XCode 等。说得更通俗一点，它其实就是浏览器里的网页。通过这种方式，可以充分利用现有的网页前端开发资源，更加方便进行插件开发与扩展。在这样一款现代、高效的工具面前，有许多值得我们去学习、打磨的地方，以便更加充分地利用它来提高我们的开发工作、甚至是日常工作的效率。  </p><p>下面，我将从 Markdown、快捷键与命令、搜索与替换、正则表达式几个比较重要、提效迅速的方面来说一下。</p><a id="more"></a><h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><p>VSCode 默认将 <code>.md</code> 后缀的文件识别为 Markdown 语言，支持 Markdown 预览。而且它还支持 Markdown inline 渲染，边编辑边渲染，实时检查、展示语法效果。代码工程里经常有各类文档文件，如 <code>README.md</code>、<code>CHANGELOG.md</code>，这样也可以直接在 VSCode 里进行编辑了。<br>同时由于它的轻量、跨平台性，还可以用来做笔记或个人数据管理。推荐大家在 Gitlab.com 上创建一个私有仓库（免费），专用存储自己的工作笔记、个人数据，并使用 VSCode 来管理、编辑，这样既可很方便地做数据同步、又能解决笔记编辑器的问题，不比那些免费或收费的专业笔记软件差。<br>为了保证 Markdown 语法的兼容性，最好确保在编辑 Markdown 文件时，制表符长度为 4 个空格。可以在 User Settings 里按如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;[markdown]&quot;: &#123;</span><br><span class="line">    &quot;editor.tabSize&quot;: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="快捷键与命令"><a href="#快捷键与命令" class="headerlink" title="快捷键与命令"></a>快捷键与命令</h2><p>VSCode 借鉴了很多其他编辑器的优秀快捷键，比如 Sublime Text。利用好快捷键能让我们尽量减少鼠标、触摸板的使用，可以让代码、文档编写工作事半功倍。好用的快捷键很多，但一开始不宜接触太多。我选择了几个效果特别好的给大家介绍下。以下快捷键主要以 macOS 为例，Windows、Linux 大体相同，但是在 Control、Command 之间存在一些不同，请自行搜索、尝试。  </p><p>选中文本的操作：  </p><ul><li><code>Command + D</code>：选中下一个跟已选中文本相同的文本。比如要选中本文内的所有 <code>Code</code>，则可以先双击选中其中一个，接着一直按 <code>Command + D</code>。每按一次就能选中下一个 <code>Code</code>。此时对某个选中的 <code>Code</code>，可以进行编辑，比如改成 <code>Code It</code>。这样所有已选中的 <code>Code</code> 都会被替换成 <code>Code It</code>。这个命令在我们写代码做重构时特别好用，不用再去用文件内搜索、定位，然后一个一个替换了。</li><li><code>Shift + Command + L</code>：选中所有跟已选中文本相同的文本。跟 <code>Command + D</code> 类似。它特别适合搭配文件内搜索、全局搜索一起使用。当我们想要用正则表达式替换文件内的某些文本，正则匹配好写、正则替换困难或不想写的情况下，可以直接选中所有匹配的文本，直接进行文字编辑。</li></ul><p>行的操作：</p><ul><li><code>Control + J</code>：将下一行合并到当前行，即取消当前行的换行符。连续使用，效果更棒，尤其是想把多行代码合并为一行的时候。</li><li><code>Shift + Command + ↓</code>：“复制”当前行为下一行。它的好处是不会占用系统剪贴板，这样剪贴板里的内容还是可以继续粘贴。</li><li><code>Shift + Command + K</code>：删除当前行。它跟 <code>Command + X</code> 的区别是，后者会将当前行复制到剪贴板再删除。</li><li><code>Command + ↑/↓</code>：移动当前行到上一行前面或下一行后面。</li></ul><p>光标定位：</p><ul><li><code>Control + A</code> 或 <code>Command + ←</code>：定位到行首</li><li><code>Control + E</code> 或 <code>Command + →</code>：定位到行末</li><li><code>Alt + ←/→</code>：定位到前一个词组或后一个词组</li></ul><h2 id="搜索与替换"><a href="#搜索与替换" class="headerlink" title="搜索与替换"></a>搜索与替换</h2><p>VSCode 的文件内搜索与替换很好用，直接 <code>Command + F</code> 就可以唤起搜索。这里我要介绍的是全局搜索。当我们要对多个文件、目录、工程进行文字搜索、替换时，尤其好用。譬如我们要替换多个工程同一个依赖的版本号，可以使用如下方法：</p><ol><li>如果这些工程在同一个目录下，那么使用 VSCode 打开该父目录即可。如果不在，可以开一个新的 VSCode 实例，使用 <code>File-&gt;Add Folder to Workspace</code> 将这些工程加到同一个 Workspace 里</li><li><code>Shift + Command + F</code> 打开全局搜索侧边栏，输入你要检索的文本。</li><li>还可以限定文件。比如只对多个工程里的 package.json 进行查找。此时展开搜索框，在 <code>files to include</code> 里写入 <code>package.json</code> 即可。</li><li>回车开始搜索。VSCode 会在下方展示出所有的匹配内容，以文件为组分隔。</li><li>点击匹配到的内容，则会打开该文件，此时可以进行手动替换。当然，也可以使用全局替换。</li></ol><p>VSCode 最近的更新（1.30.1）也支持多行文本的全局替换了！搜索框内支持回车（但是要按 <code>Shift + Enter</code>），这样多行文本的搜索也很好用了，不能更赞！（想当初我还不得不用 Python 命令行脚本去解决这个需求）</p><h2 id="关于正则表达式"><a href="#关于正则表达式" class="headerlink" title="关于正则表达式"></a>关于正则表达式</h2><p>最后，我想额外提一下正则表达式。正则表达式不仅是编程时可能需要用到，我们正常的文本编辑其实用到的机会会更多，尤其是在进行搜索、替换时。很多人调侃：“正则我每次只要半个小时就会”。的确，简单的正则，如 <code>.*</code>、<code>\d</code>、<code>\w</code>，网上有很多文章介绍使用。甚至一些较为复杂的也能通过谷歌搜索得到。但是之所以能忍受 <code>每次</code> 都花“半个小时”去搜索，就是没有经常使用的缘故。反过来说，如果经常使用，也就不需要花那“半个小时”去搜索了。<br>所以，在进行代码编辑、文档处理或者其他任务时，多使用编辑器提供给我们的正则表达式搜索与替换的能力，会让我们对它自然熟悉。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>VSCode 还有很多地方值得我们深入探索，包括常用插件、工程配置等。它是我们的开发工作、日常工作的效率倍增器，一定要多加思考、多加练习、多加利用。磨刀不误砍柴工。很多时候我们不知道自己的刀快不快，看到别人砍柴快了，也许我们就知道该怎么做了。希望这些技巧能能带动大家“磨刀”的兴趣。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我看开发</title>
      <link href="/the-developer-i-want/"/>
      <url>/the-developer-i-want/</url>
      
        <content type="html"><![CDATA[<p>哪些能力是一位优秀的开发人员在技术上应该具备的？这是一个老生常谈的问题。就像很多人简历里所描述的，“解决问题能力强”、”善于学习“、”积极思考“，以及各种“精通某某某”等。毋庸置疑，能做到这些的人的确可以称得上“优秀”。但我总感觉它们就像散落一地的珍珠，缺少那么一根线来串起来。我想要一个具有提纲掣领的评判依据，甚至在这个纲领下，能够从一种更高的高度去引导我们开发人员的发展方向，更好地帮助他们进行技能学习。在这些年的研发、面试、技术管理工作中，我更倾向于从以下三个角度去认识一位开发人员：工具、编码、设计。<br><a id="more"></a></p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>所谓工具，就是指开发人员对他们用以编程的各种软件、系统，高效率使用、定制化扩展的能力，甚至还包括创造这些辅助软件的能力。马克思曾说，人与动物的区别是制造和使用工具。孔子也有言，工欲善其事，必先利其器。我们不光要使用工具，还要去改进工具，甚至通过工具去制造更加高级的工具。大部分情况下，我们能够做到使用工具，使用一些大众知晓、团队统一的工具。但很多时候，我们对这些工具的使用方式容易形成惯性，对一些没有效率的细节习以为常。即便某些时候，感觉到某些不方便，还是不以为意，不去想是否可以改进。甚至在目前的工具下无法很好、很快地完成某项任务时，我们还会在心里抱怨那些提出这个任务的人。</p><p>为什么会有这些问题存在呢？我想，可能是我们自己都忽视了，软件开发这项工作，可以说是世界上最具灵活性、扩展性的工作了。它可以以成本非常低廉的方式进行自我进化！在我们开发软件的过程中，可以先开发出额外的软件用以帮助我们的开发工作。如此往复，递归推进，没有哪一个行业具备这样的发展方式。身处其中的我们，很有必要认识到这一点。</p><p>所以这里把工具放到第一位，是因为它所表现出来的能力水平，往往可以作为一个开发人员是否”觉醒着“的标记。一个对工具没有认识的人，更可能是一个在开发工作中因循守旧、缺乏生机的人。天花板不高，发展潜力有限。而一个能把工具更高效地利用好的人，相信在接下来的编码、设计方面，也能有更好地表现。</p><p>工具不仅包括跟开发直接相关的部分，如操作系统、IDE、浏览器、命令行、需求管理、版本管理等，还包括日常生活中会使用到的各种软件或服务，如即时通讯、日程管理、邮箱、文件管理、翻译等。除了这些已有的软件或服务外，对一些通用的功能概念也要烂熟于心，如正则表达式、通用文本编辑快捷键等。再者就是对于需要再造工具的场景，要会使用一些脚本语言自行编写，如 Bash、Python、JavaScript。这些脚本语言的运用，自然也需要在编码上下一番功夫。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>编码，这大概是开发人员觉得自己最有把握的事情了。编码不就是把功能需求用一门高级语言实现出来嘛！实现的细节不就是各种 if、for、赋值等语句的组装嘛！而且，最终用户可能只关心整个系统的功能是否正常，他们不会关心内部是怎样去实现的。“功能正常”，这既是最高的要求，却往往也是最低的要求。作为开发者，要认识到仅仅让功能正常也许比较简单，但实现时粗糙的编码可能会藏有各种难以发现的问题。这样在某一时刻或情景下，“功能正常”也就无法保证。就像《The Art of Computer Programming》这本书名所表示的那样，如果我们把编程当做一门艺术，抱着雕琢自己作品的态度去面对代码，就不会仅仅只局限于它的外在，而不在乎其内在了。</p><p>然而在编码这件事上，很多人又容易走极端，极尽所能地去研究那些奇技淫巧，甚至以此作为炫耀的资本。比如利用运算符优先级编写极其复杂的计算表达式、利用语言特性实现极其难以理解的逻辑。每一门语言都有一些犄角旮旯的特性，甚至有所不足或缺陷。但在我们正常的开发工作中，应该尽量去避免触碰这些陷阱。把那些绕脑的、存在歧义的语法与写法通通扔掉。多去研究那些更加现代、安全、人性化的表达方式。</p><p>好的编码，首先风格就很不一样。一个具有良好目录组织结构的工程、一段具有良好命名的代码，都会让人看起来赏心悦目、心旷神怡。然后就是对语言层面各种语法要运用自如。对各种高级语法的底层实现要抱有一颗求索的心，甚至由此追溯到汇编、机器码乃至计算机硬件。还有安全性、性能、扩展性等各个方面。而后面这些，其实就已经上升到设计层面了。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>那什么是设计呢？如果把编码看做”行（xíng）“，那么设计就是”思“。行成于思毁于随，还要三思而后行。”思“，首先要从业务、产品的高度上进行求证：这个功能它的目的是什么？它的工作场景是什么？它有无存在的必要或者改善的可能？其次就是从使用者的角度换位思考：如果我是用户，我需要的是什么？我会如何去做某件事？我完成的效率能否提升？最后就是我们的技术上考量：数据结构该如何去设计？如何应对可能的修改？如何保证程序的健壮性？如何应对高并发的场景？等等，不一而足。良好的设计能够让我们规避代码修改的泥淖、跳过未知缺陷的深渊。</p><p>希望通过工具、编码、设计这么一根准绳，穿入我们日常的开发工作中，能够让我们时刻保持清醒、明确的研究思路，握紧发展的方向舵。祝愿大家！</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Coding </tag>
            
            <tag> Think </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Turn over a new leaf</title>
      <link href="/turn-over-a-new-leaf/"/>
      <url>/turn-over-a-new-leaf/</url>
      
        <content type="html"><![CDATA[<p>时隔近十年，心里又重新动起了写点文字的念头。倒不是说要达到著书立说的高度，而是觉得把东西公开写出来，比自己私下做些日记或笔记会更多一点东西。在一定程度上，它可以促使我以更加严谨地态度去对待经验。虽然是我个人的经验，但可能对别人也会有一些用，满足一下虚荣❤。<br><a id="more"></a></p><p>作为一个 Web 开发程序员，技术肯定会比较多地谈及。但互联网上已经有千千万万地技术分享、讨论，重复或原创，应接不暇。而我的初心，绝不想做完全重复的事情–像所谓布道士一样去无限强调某种东西来做宣传。我所要谈的内容，只是代表我自己，抑或可能存在的某一些人，以某种思维方式去理解的技术。也许比较粗浅，甚至存在错漏，但没关系，至少它描绘了我学习、成长的轨迹。</p><p>除了技术上的内容，偶尔可能还会夹杂一些“无聊”的东西，譬如随想、生活经验、音乐分享之类。总而言之，这个博客，它将不存在一个明显的主线：零零碎碎，甚至杂乱无章。但是这些我选择发表出来的东西，它们构成了一个一个重要的时间节点。若干年后，当我回顾时，这便是我的人生学习轨迹！乃至激励我：人生不止，奋斗不息！</p>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Misc </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
